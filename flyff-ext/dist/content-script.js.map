{"version":3,"file":"content-script.js","mappings":"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","sources":["webpack:///./src/shared/utils/hex.js","webpack:///./src/content-script/memory/index.js","webpack:///./src/shared/utils/merge.js","webpack:///./src/content-script/instrument/find-function.js","webpack:///./src/content-script/instrument/hooks/decryption.js","webpack:///./src/content-script/instrument/hooks/encryption.js","webpack:///./src/content-script/instrument/index.js","webpack:///./src/content-script/wasm-trigger/instantiate.js","webpack:///./src/content-script/wasm-trigger/instantiateStreaming.js","webpack:///./src/content-script/index.js","webpack:///./src/shared/utils/log.js","webpack:///./src/content-script/debugger-protection.js","webpack:///./src/content-script/wasm-trigger/index.js"],"sourcesContent":["export default function toHex(i) {\n\treturn '0x' + parseInt(i).toString(16).padStart(8, '0');\n};","import toHex from \"../../shared/utils/hex.js\";\n\nexport class MemoryWrapper {\n\n    constructor(memory) {\n        this.memory = memory;\n    }\n\n    getMemoryType(memType) {\n        switch (memType) {\n            case \"i8\":\n            case \"ascii\":\n            case \"bytes\":\n                return Uint8Array;\n            case \"i16\":\n            case \"utf-8\":\n                return Uint16Array;\n            case \"i32\":\n                return Uint32Array;\n            case \"i64\":\n                return BigInt64Array;\n            case \"f32\":\n                return Float32Array;\n            case \"f64\":\n                return Float64Array;\n            default:\n                throw new Error(\"Invalid memory type \" + memType + \" in getMemoryType()\");\n        }\n    }\n\n    // Accessing aligned memory is faster because we can just treat the whole\n    // memory object as the relevant typed array (Like Uint32Array)\n    // This is not as thorough, however, because we will miss matching values\n    // that are not stored at naturally-aligned addresses\n    alignedMemory(memTypeStr) {\n        const memType = this.getMemoryType(memTypeStr);\n\n        // We return a new object each time because the WebAssembly.Memory object\n        // will detach if it is resized\n        return new memType(this.memory.buffer);\n    }\n\n    // When we need to access unaligned memory addresses, we treat memory as a\n    // Uint8Array so that we can read at any \"real\" address\n    unalignedMemory() {\n        return new Uint8Array(this.memory.buffer);\n    }\n\n    getMemorySize() {\n        return this.unalignedMemory().length;\n    }\n\n    search(memType, searchValue, lowerBound, upperBound) {\n        const result = {};\n\n        let realLowerBound = parseInt(lowerBound);\n        let realUpperBound = parseInt(upperBound);\n\n        if (realLowerBound < 0) {\n            realLowerBound = 0;\n        }\n\n        const memSize = this.getMemorySize();\n\n        if (realUpperBound >= memSize) {\n            realUpperBound = memSize - 1;\n        }\n\n        let realParam;\n\n        switch (memType) {\n            case \"ascii\":\n                realParam = new Uint8Array(searchValue.length);\n\n                for (let i = 0; i < searchValue.length; i++) {\n                    realParam[i] = searchValue.charCodeAt(i);\n                }\n\n                break;\n            case \"utf-8\":\n                const tempBuf = new Uint16Array(searchValue.length);\n\n                for (let i = 0; i < searchValue.length; i++) {\n                    realParam[i] = searchValue.charCodeAt(i);\n                }\n\n                realParam = new Uint8Array(tempBuf.buffer);\n\n                break;\n            case \"bytes\":\n                if (Array.isArray(searchValue)) {\n                    realParam = new Uint8Array(searchValue);\n                } else {\n                    const split1 = [...searchValue.trim().matchAll(/\\\\x[0-9a-f]{2}(?![0-9a-z])/gi)];\n                    const split2 = searchValue.trim().split(/\\\\x/);\n\n                    if ((split1.length != (split2.length - 1)) || split1.length == 0) {\n                        // Something is wrong in the byte sequence\n                        console.error(\"Wrong byte sequence format\");\n                        return;\n                    }\n\n                    split2.shift();\n\n                    realParam = new Uint8Array(split2.length);\n                    for (let i = 0; i < searchValue.length; i++) {\n                        realParam[i] = parseInt(split2[i], 16);\n                    }\n                }\n\n                break;\n        }\n\n        const searchResults = this.bytesSequence(realParam);\n\n        result.results = {};\n\n        for (let i = 0; i < searchResults.length; i++) {\n            const hitAddr = searchResults[i];\n            result.results[hitAddr] = searchValue;\n            wyff.logger.info(`${toHex(hitAddr)}: ${searchValue}`);\n        }\n\n        result.count = searchResults.length;\n\n        return result;\n    }\n\n    bytesSequence(bytesSeq) {\n        wyff.logger.debug(\"bytesSequence: entering bytes sequence search with parameter \" + bytesSeq);\n\n        if (bytesSeq.length < 1) {\n            wyff.logger.error(\"Minimum length must be at least 1!\");\n            return [];\n        } else if (bytesSeq.length < 4) {\n            wyff.logger.debug(\"Sequence length is small: \" + bytesSeq.length + \". This will probably return a lot of results!\");\n        }\n\n        const results = [];\n        const memory = this.alignedMemory(\"i8\");\n        let match = 0;\n\n        for (let i = 0; i < memory.length; i++) {\n            const thisByte = memory[i];\n\n            if (thisByte == bytesSeq[match]) {\n                match++;\n                continue;\n            }\n            \n            if (match == bytesSeq.length) {\n                results.push(i - bytesSeq.length);\n                match = 0;\n                wyff.logger.debug(\"bytesSequence: sequence found: \" + bytesSeq);\n            } else {\n                match = 0;\n            }\n        }\n\n        wyff.logger.debug(\"bytesSequence: exiting bytes sequence search\");\n        return results;\n    }\n\n    readBytes(address, size = 16, intSize = 8, asAscii = false) {\n        const bytes = [];\n        let buffer;\n        if (intSize === 8) {\n            buffer = new Int8Array(this.memory.buffer);\n        } else if (intSize === 32) {\n            buffer = new Int32Array(this.memory.buffer);\n        }\n        for (let i = 0; i < size; i++) {\n            bytes.push(buffer[address + i]);\n        }\n    \n        if (asAscii) {\n            return bytes.map(byte => String.fromCharCode(byte)).join('');\n        }\n    \n        return bytes;\n    }\n    \n}","/**\n * Simple object check.\n * @param item\n * @returns {boolean}\n */\nexport function isObject(item) {\n    return (item && typeof item === 'object' && !Array.isArray(item));\n}\n\n/**\n * Deep merge two objects.\n * @param target\n * @param ...sources\n */\nexport function mergeDeep(target, ...sources) {\n    if (!sources.length) return target;\n    const source = sources.shift();\n\n    if (isObject(target) && isObject(source)) {\n        for (const key in source) {\n            if (isObject(source[key])) {\n                if (!target[key]) Object.assign(target, { [key]: {} });\n                mergeDeep(target[key], source[key]);\n            } else {\n                Object.assign(target, { [key]: source[key] });\n            }\n        }\n    }\n\n    return mergeDeep(target, ...sources);\n}","export default function findFunctionUsingBytes(parser, bytesToFind) {\n    // Convert bytesToFind to a Uint8Array and mark where the wildcards are\n    const wildcardIndexes = [];\n    const buffer = new BufferReader();\n    bytesToFind.forEach(v => {\n        if (v === '?') {\n            wildcardIndexes.push(buffer.length);\n            buffer.copyBuffer([0x00]);\n        } else {\n            buffer.copyBuffer(Array.isArray(v) ? v : [v]);\n        }\n    });\n\n    // set stuff up\n    const bytesToFindView = new Uint8Array(buffer.write())\n    const copyParser = new WailParser(parser.inBuffer);\n    const matchingFunctionIndexes = [];\n\n    const checkIfFunctionMatches = function ({ index: functionIndex, bytes: codeBytes }) {\n        let startIndex;\n        for (let i = 0; i < codeBytes.length; i++) {\n            if (codeBytes[i] === bytesToFindView[0]) {\n                let match = true;\n                startIndex = i;\n                for (let j = 1; j < bytesToFindView.length; j++) {\n                    if (codeBytes[i + j] !== bytesToFindView[j] && !wildcardIndexes.includes(j)) {\n                        match = false;\n                        break;\n                    }\n                }\n\n                if (match) {\n                    matchingFunctionIndexes.push(functionIndex);\n                    wyff.logger.debug(`Found function using bytes`, { bytesToFindView, functionIndex, matchedBytes: codeBytes.subarray(startIndex, startIndex + bytesToFindView.length) });\n                }\n            }\n        }\n\n        return codeBytes;\n    }\n\n    // Parse and handle each individual function to see if the code bytes match\n    copyParser.addCodeElementParser(null, checkIfFunctionMatches);\n    copyParser.parse();\n\n    if (matchingFunctionIndexes.length === 0) {\n        wyff.logger.error(`Could not find function using bytes`, { bytesToFindView });\n        throw new Error(\"Could not find function using bytes\");\n    }\n\n    if (matchingFunctionIndexes.length > 1) {\n        wyff.logger.error(`Found multiple functions using bytes`, { bytesToFindView, matchingFunctionIndexes });\n        throw new Error(\"Found multiple functions using bytes\");\n    }\n\n    return matchingFunctionIndexes[0];\n}","import findFunctionUsingBytes from \"../find-function\";\n\nexport function decryptionFunctionHook(beginAddress, endAddress) {\n    // Using the beginAddress and endAddress, we can get the message payload\n    const length = endAddress - beginAddress;\n    const message = new Uint8Array(wasmMemory.buffer, beginAddress, length);\n    // convert to ascii\n    const messageAscii = new TextDecoder(\"ascii\").decode(message);\n    wyff.logger.info(`RECEIVED\\n%c${message.join(\"\\t\")}%c\\n%c${messageAscii}`, 'background: #c4e2ff; color: black;', '', 'background: #c4d0ff; color: black;');\n}\n\nexport function hookDecryptionFunction(parser, hookRef) {\n    const functionIndex = findFunctionUsingBytes(parser, [\n        OP_GET_LOCAL, VarUint32(0x02),\n        OP_I32_LOAD, VarUint32(0x02), VarUint32(36),\n        OP_I32_LOAD, 0x00, VarUint32(5),\n    ]);\n\n    wyff.logger.info(`Found decryption function`, { functionIndex });\n\n    parser.addCodeElementParser(parser._getAdjustedFunctionIndex(functionIndex), function ({ bytes }) {\n        const reader = new BufferReader(bytes);\n\n        // push the original function without the last END byte\n        reader.copyBuffer(bytes.subarray(0, bytes.length - 1));\n\n        /**\n         * At the very end of the decryption function,\n         * var0 is a memory address that contains the address of the beginning of the message payload.\n         * var1 is a memory address that contains the address of the end of the message payload.\n         */\n        reader.copyBuffer([ OP_GET_LOCAL ]);\n        reader.copyBuffer(VarUint32(0x00));\n        reader.copyBuffer([ OP_GET_LOCAL ]);\n        reader.copyBuffer(VarUint32(0x01));\n        reader.copyBuffer([ OP_CALL ]);\n        reader.copyBuffer(hookRef.varUint32());\n\n        reader.copyBuffer([ OP_END ]);\n\n        return reader.write();\n    });\n}","import { uint64ToUint8Array } from \"../../../shared/utils/bytes\";\nimport findFunctionUsingBytes from \"../find-function\";\n\nexport function encryptionFunctionHook(ptr) {\n    /**\n     * Now we have the address of the beginning of the message payload\n     * var0+4 is an address that contains the address of the end of the message payload\n     */\n    const dataview = new DataView(wasmMemory.buffer);\n\n    const beginningOfMsgPtr = dataview.getUint32(ptr, true);\n    const endOfMsgPtr = dataview.getUint32(ptr + 4, true);\n\n    // calculate length using addresses\n    const messageLength = endOfMsgPtr - beginningOfMsgPtr;\n    // get the message\n    const message = new Uint8Array(wasmMemory.buffer, beginningOfMsgPtr, messageLength);\n    // convert to ascii\n    const messageAscii = new TextDecoder(\"ascii\").decode(message);\n\n    wyff.logger.info(`SENDING\\n%c${message.join(\"\\t\")}%c\\n%c${messageAscii}`, 'background: #c4ffcd; color: black;', '', 'background: #a7facd; color: black;');\n}\n\nexport function hookEncryptionFunction(parser, hookRef) {\n    const functionIndex = findFunctionUsingBytes(parser, [\n        /**\n         * These bytes are like the very beginning of the encryption function\n         */\n        OP_GET_LOCAL, VarUint32(0x00),\n        OP_I32_LOAD, VarUint32(0x02), VarUint32(4),\n        OP_TEE_LOCAL, VarUint32(0x02),\n        OP_GET_LOCAL, VarUint32(0x00),\n        OP_I32_LOAD, VarUint32(0x02), VarUint32(0x00),\n        OP_TEE_LOCAL, VarUint32(0x03),\n        OP_I32_SUB,\n        OP_SET_LOCAL, VarUint32(0x06),\n        OP_I32_CONST, 9,\n        OP_SET_LOCAL, VarUint32(0x07),\n    ]);\n\n    wyff.logger.info(`Found encryption function`, { functionIndex });\n\n    parser.addCodeElementParser(parser._getAdjustedFunctionIndex(functionIndex), function ({ bytes }) {\n        const reader = new BufferReader(bytes);\n\n        /**\n         * At the beginning of the encryption function, var0 is a memory address\n         * that contains the address of the beginning of the message payload.\n         */\n\n        // push the first arg of the function onto the stack\n        reader.copyBuffer([ OP_GET_LOCAL ]);\n        reader.copyBuffer(VarUint32(0x00));\n        // call the hook function\n        reader.copyBuffer([ OP_CALL ]);\n        reader.copyBuffer(hookRef.varUint32());\n\n        // push the rest of the function\n        reader.copyBuffer(bytes);\n        return reader.write();\n    });\n}","import { decryptionFunctionHook, hookDecryptionFunction } from \"./hooks/decryption.js\";\nimport { encryptionFunctionHook, hookEncryptionFunction } from \"./hooks/encryption.js\";\n\nfunction instrumentResults(imports, binary) {\n    return { imports, binary };\n}\n\nfunction importFunction(parser, name, params, returnType) {\n    // Add a new function into the wasm binary\n    // 'env' is referring to the import object name that contains\n    // all of our imports. \n    return parser.addImportEntry({\n        moduleStr: \"env\",\n        fieldStr: name,\n        kind: \"func\",\n        type: parser.addTypeEntry({\n            form: \"func\",\n            params: params,\n            returnType: returnType\n        })\n    });\n}\n\nexport default function instrumentBinary(binary) {\n    const parser = new WailParser(binary);\n    const imports = {\n        env: {\n            encryptionHook: encryptionFunctionHook,\n            decryptionHook: decryptionFunctionHook\n        }\n    };\n\n    // Import all functions up front so the function indexes are known\n    const encryptionHookRef = importFunction(parser, \"encryptionHook\", [\"i32\"]);\n    const decryptionHookRef = importFunction(parser, \"decryptionHook\", [\"i32\", \"i32\"]);\n\n    try {\n        hookEncryptionFunction(parser, encryptionHookRef);\n    } catch (e) {\n        wyff.logger.error(`error hooking encryption function`);\n        wyff.logger.error(e);\n    }\n\n    try {\n        hookDecryptionFunction(parser, decryptionHookRef);\n    } catch (e) {\n        wyff.logger.error(`error hooking decryption function`);\n        wyff.logger.error(e);\n    }\n\n    // parse and write the new binary\n    parser.parse();\n    return instrumentResults(imports, parser.write());\n}","import { mergeDeep } from \"../../shared/utils/merge\";\nimport instrumentBinary from \"../instrument\";\n\nfunction createHookFunction(original) {\n    return async function(bufferSource, importObject = {}) {\n        wyff.logger.debug(\"WebAssembly.instantiate() intercepted\");\n\n        const instrumentResults = instrumentBinary(bufferSource);\n        if (instrumentResults.imports) {\n            importObject = mergeDeep(importObject, instrumentResults.imports);\n        }\n\n        return original(instrumentResults.binary, importObject);\n    };\n}\n\nexport default function hookInstantiate() {\n    const oldFunction = WebAssembly.instantiate;\n    const hook = createHookFunction(oldFunction);\n    window.WebAssembly.instantiate = hook;\n}\n","async function getSourceBuffer() {\n    if (sourceObj instanceof Promise) {\n        const res = await sourceObj;\n        return res.arrayBuffer()\n    } else if (sourceObj instanceof Response) {\n        return await sourceObj.arrayBuffer();\n    } else {\n        throw new Error(\"Got unexpected object type as first argument to WebAssembly.instantiateStreaming\");\n    }\n}\n\nfunction createHookFunction(original) {\n    return async function(sourceObj, importObject = {}) {\n        wyff.logger.debug(\"WebAssembly.instantiateStreaming() intercepted\");\n        const buffer = await getSourceBuffer(sourceObj);\n        return WebAssembly.instantiate(buffer, importObject);\n    };\n}\n\nexport default function hookInstantiateStreaming() {\n    const oldFunction = WebAssembly.instantiateStreaming;\n    const hook = createHookFunction(oldFunction);\n    window.WebAssembly.instantiateStreaming = hook;\n}\n","import Log from \"../shared/utils/log.js\";\nimport removeDebuggerProtection from \"./debugger-protection.js\";\nimport { MemoryWrapper } from \"./memory/index.js\";\nimport hookWASMTriggerFunctions from \"./wasm-trigger/index.js\";\n\nconst logger = new Log();\nwindow.wyff = {\n    logger,\n};\n\nsetInterval(() => {\n    if (window.wasmMemory !== undefined) {\n        window.MemoryWrapper = new MemoryWrapper(wasmMemory);\n    }\n})\n\nremoveDebuggerProtection();\nhookWASMTriggerFunctions();","export default class Log {\n    constructor(infoWriter, debugWriter, errorWriter) {\n        this.infoWriter = infoWriter || console.log;\n        this.debugWriter = debugWriter || console.debug;\n        this.errorWriter = errorWriter || console.error;\n\n        const prefixStyle = [\n            \"font-size: 1.6em\",\n            \"font-weight: bold\",\n            \"text-transform: uppercase\",\n        ].join(\";\");\n\n        this.info = this.infoWriter.bind(console, \"%c[WYFF]%c INFO\\t%s\", prefixStyle, \"\");\n        this.debug = this.debugWriter.bind(console, \"%c[WYFF]%c DEBUG\\t%s\", prefixStyle, \"\");\n        this.error = this.errorWriter.bind(console, \"%c[WYFF]%c ERROR\\t%s\", prefixStyle, \"\");\n    }\n}\n","export default function removeDebuggerProtection(logger) {\n    wyff.logger.debug(`hooking function to remove debugger protection`);\n\n    window._Function = Function;\n    window.Function = function() {\n        window.c = (a) => (a ? () => () => {} : null);\n        wyff.logger.debug(`debugger protection removed`);\n        const fn = window._Function.apply(this, arguments);\n        window.Function = window._Function;\n        return fn;\n    };\n}","import hookInstantiate from \"./instantiate.js\";\nimport hookInstantiateStreaming from \"./instantiateStreaming.js\";\n\nexport default function hookWASMTriggerFunctions() {\n    wyff.logger.info(`hooking WASM functions`);\n\n    // We need to hook into these two functions to capture when the wasm binary is about to be loaded\n    // in and parsed by the browser. We can modify the binary before it reaches the browser engine.\n    //\n    // These hooks end up calling the instrumentBinary() function\n    hookInstantiate();\n    hookInstantiateStreaming();\n}"],"names":["toHex","i","parseInt","toString","padStart","MemoryWrapper","constructor","memory","this","getMemoryType","memType","Uint8Array","Uint16Array","Uint32Array","BigInt64Array","Float32Array","Float64Array","Error","alignedMemory","memTypeStr","buffer","unalignedMemory","getMemorySize","length","search","searchValue","lowerBound","upperBound","result","realLowerBound","realUpperBound","memSize","realParam","charCodeAt","tempBuf","Array","isArray","split1","trim","matchAll","split2","split","console","error","shift","searchResults","bytesSequence","results","hitAddr","wyff","logger","info","count","bytesSeq","debug","match","push","readBytes","address","size","intSize","asAscii","bytes","Int8Array","Int32Array","map","byte","String","fromCharCode","join","isObject","item","mergeDeep","target","sources","source","key","Object","assign","findFunctionUsingBytes","parser","bytesToFind","wildcardIndexes","BufferReader","forEach","v","copyBuffer","bytesToFindView","write","copyParser","WailParser","inBuffer","matchingFunctionIndexes","addCodeElementParser","index","functionIndex","codeBytes","startIndex","j","includes","matchedBytes","subarray","parse","decryptionFunctionHook","beginAddress","endAddress","message","wasmMemory","messageAscii","TextDecoder","decode","encryptionFunctionHook","ptr","dataview","DataView","beginningOfMsgPtr","getUint32","messageLength","importFunction","name","params","returnType","addImportEntry","moduleStr","fieldStr","kind","type","addTypeEntry","form","createHookFunction","original","async","bufferSource","importObject","instrumentResults","binary","imports","env","encryptionHook","decryptionHook","encryptionHookRef","decryptionHookRef","hookRef","OP_GET_LOCAL","VarUint32","OP_I32_LOAD","OP_TEE_LOCAL","OP_I32_SUB","OP_SET_LOCAL","OP_I32_CONST","_getAdjustedFunctionIndex","reader","OP_CALL","varUint32","hookEncryptionFunction","e","OP_END","hookDecryptionFunction","instrumentBinary","getSourceBuffer","sourceObj","Promise","arrayBuffer","Response","infoWriter","debugWriter","errorWriter","log","prefixStyle","bind","window","setInterval","undefined","_Function","Function","c","a","fn","apply","arguments","hook","WebAssembly","instantiate","hookInstantiate","instantiateStreaming"],"sourceRoot":""}