{"version":3,"file":"content-script.js","mappings":"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","sources":["webpack:///./src/shared/utils/hex.js","webpack:///./src/content-script/memory/index.js","webpack:///./src/shared/utils/merge.js","webpack:///./src/content-script/instrument/find-function.js","webpack:///./src/content-script/instrument/hooks/received-hooks/combat.js","webpack:///./src/content-script/instrument/hooks/decryption.js","webpack:///./src/content-script/instrument/hooks/received-hooks/index.js","webpack:///./src/content-script/instrument/hooks/sending-hooks/movement.js","webpack:///./src/content-script/instrument/hooks/encryption.js","webpack:///./src/content-script/instrument/hooks/sending-hooks/index.js","webpack:///./src/content-script/instrument/index.js","webpack:///./src/content-script/wasm-trigger/instantiate.js","webpack:///./src/content-script/wasm-trigger/instantiateStreaming.js","webpack:///./src/content-script/index.js","webpack:///./src/shared/utils/log.js","webpack:///./src/content-script/debugger-protection.js","webpack:///./src/content-script/wasm-trigger/index.js"],"sourcesContent":["export default function toHex(i) {\r\n\treturn '0x' + parseInt(i).toString(16).padStart(8, '0');\r\n};","import toHex from \"../../shared/utils/hex.js\";\r\n\r\nexport class MemoryWrapper {\r\n\r\n    constructor(memory) {\r\n        this.memory = memory;\r\n    }\r\n\r\n    getMemoryType(memType) {\r\n        switch (memType) {\r\n            case \"i8\":\r\n            case \"ascii\":\r\n            case \"bytes\":\r\n                return Uint8Array;\r\n            case \"i16\":\r\n            case \"utf-8\":\r\n                return Uint16Array;\r\n            case \"i32\":\r\n                return Uint32Array;\r\n            case \"i64\":\r\n                return BigInt64Array;\r\n            case \"f32\":\r\n                return Float32Array;\r\n            case \"f64\":\r\n                return Float64Array;\r\n            default:\r\n                throw new Error(\"Invalid memory type \" + memType + \" in getMemoryType()\");\r\n        }\r\n    }\r\n\r\n    // Accessing aligned memory is faster because we can just treat the whole\r\n    // memory object as the relevant typed array (Like Uint32Array)\r\n    // This is not as thorough, however, because we will miss matching values\r\n    // that are not stored at naturally-aligned addresses\r\n    alignedMemory(memTypeStr) {\r\n        const memType = this.getMemoryType(memTypeStr);\r\n\r\n        // We return a new object each time because the WebAssembly.Memory object\r\n        // will detach if it is resized\r\n        return new memType(this.memory.buffer);\r\n    }\r\n\r\n    // When we need to access unaligned memory addresses, we treat memory as a\r\n    // Uint8Array so that we can read at any \"real\" address\r\n    unalignedMemory() {\r\n        return new Uint8Array(this.memory.buffer);\r\n    }\r\n\r\n    getMemorySize() {\r\n        return this.unalignedMemory().length;\r\n    }\r\n\r\n    search(memType, searchValue, lowerBound, upperBound) {\r\n        const result = {};\r\n\r\n        let realLowerBound = parseInt(lowerBound);\r\n        let realUpperBound = parseInt(upperBound);\r\n\r\n        if (realLowerBound < 0) {\r\n            realLowerBound = 0;\r\n        }\r\n\r\n        const memSize = this.getMemorySize();\r\n\r\n        if (realUpperBound >= memSize) {\r\n            realUpperBound = memSize - 1;\r\n        }\r\n\r\n        let realParam;\r\n\r\n        switch (memType) {\r\n            case \"ascii\":\r\n                realParam = new Uint8Array(searchValue.length);\r\n\r\n                for (let i = 0; i < searchValue.length; i++) {\r\n                    realParam[i] = searchValue.charCodeAt(i);\r\n                }\r\n\r\n                break;\r\n            case \"utf-8\":\r\n                const tempBuf = new Uint16Array(searchValue.length);\r\n\r\n                for (let i = 0; i < searchValue.length; i++) {\r\n                    realParam[i] = searchValue.charCodeAt(i);\r\n                }\r\n\r\n                realParam = new Uint8Array(tempBuf.buffer);\r\n\r\n                break;\r\n            case \"bytes\":\r\n                if (Array.isArray(searchValue)) {\r\n                    realParam = new Uint8Array(searchValue);\r\n                } else {\r\n                    const split1 = [...searchValue.trim().matchAll(/\\\\x[0-9a-f]{2}(?![0-9a-z])/gi)];\r\n                    const split2 = searchValue.trim().split(/\\\\x/);\r\n\r\n                    if ((split1.length != (split2.length - 1)) || split1.length == 0) {\r\n                        // Something is wrong in the byte sequence\r\n                        console.error(\"Wrong byte sequence format\");\r\n                        return;\r\n                    }\r\n\r\n                    split2.shift();\r\n\r\n                    realParam = new Uint8Array(split2.length);\r\n                    for (let i = 0; i < searchValue.length; i++) {\r\n                        realParam[i] = parseInt(split2[i], 16);\r\n                    }\r\n                }\r\n\r\n                break;\r\n        }\r\n\r\n        const searchResults = this.bytesSequence(realParam);\r\n\r\n        result.results = {};\r\n\r\n        for (let i = 0; i < searchResults.length; i++) {\r\n            const hitAddr = searchResults[i];\r\n            result.results[hitAddr] = searchValue;\r\n            wyff.logger.info(`${toHex(hitAddr)}: ${searchValue}`);\r\n        }\r\n\r\n        result.count = searchResults.length;\r\n\r\n        return result;\r\n    }\r\n\r\n    bytesSequence(bytesSeq) {\r\n        wyff.logger.debug(\"bytesSequence: entering bytes sequence search with parameter \" + bytesSeq);\r\n\r\n        if (bytesSeq.length < 1) {\r\n            wyff.logger.error(\"Minimum length must be at least 1!\");\r\n            return [];\r\n        } else if (bytesSeq.length < 4) {\r\n            wyff.logger.debug(\"Sequence length is small: \" + bytesSeq.length + \". This will probably return a lot of results!\");\r\n        }\r\n\r\n        const results = [];\r\n        const memory = this.alignedMemory(\"i8\");\r\n        let match = 0;\r\n\r\n        for (let i = 0; i < memory.length; i++) {\r\n            const thisByte = memory[i];\r\n\r\n            if (thisByte == bytesSeq[match]) {\r\n                match++;\r\n                continue;\r\n            }\r\n            \r\n            if (match == bytesSeq.length) {\r\n                results.push(i - bytesSeq.length);\r\n                match = 0;\r\n                wyff.logger.debug(\"bytesSequence: sequence found: \" + bytesSeq);\r\n            } else {\r\n                match = 0;\r\n            }\r\n        }\r\n\r\n        wyff.logger.debug(\"bytesSequence: exiting bytes sequence search\");\r\n        return results;\r\n    }\r\n\r\n    readBytes(address, size = 16, intSize = 8, asAscii = false) {\r\n        const bytes = [];\r\n        let buffer;\r\n        if (intSize === 8) {\r\n            buffer = new Int8Array(this.memory.buffer);\r\n        } else if (intSize === 32) {\r\n            buffer = new Int32Array(this.memory.buffer);\r\n        }\r\n        for (let i = 0; i < size; i++) {\r\n            bytes.push(buffer[address + i]);\r\n        }\r\n    \r\n        if (asAscii) {\r\n            return bytes.map(byte => String.fromCharCode(byte)).join('');\r\n        }\r\n    \r\n        return bytes;\r\n    }\r\n    \r\n}","/**\r\n * Simple object check.\r\n * @param item\r\n * @returns {boolean}\r\n */\r\nexport function isObject(item) {\r\n    return (item && typeof item === 'object' && !Array.isArray(item));\r\n}\r\n\r\n/**\r\n * Deep merge two objects.\r\n * @param target\r\n * @param ...sources\r\n */\r\nexport function mergeDeep(target, ...sources) {\r\n    if (!sources.length) return target;\r\n    const source = sources.shift();\r\n\r\n    if (isObject(target) && isObject(source)) {\r\n        for (const key in source) {\r\n            if (isObject(source[key])) {\r\n                if (!target[key]) Object.assign(target, { [key]: {} });\r\n                mergeDeep(target[key], source[key]);\r\n            } else {\r\n                Object.assign(target, { [key]: source[key] });\r\n            }\r\n        }\r\n    }\r\n\r\n    return mergeDeep(target, ...sources);\r\n}","export default function findFunctionUsingBytes(parser, bytesToFind) {\r\n    // Convert bytesToFind to a Uint8Array and mark where the wildcards are\r\n    const wildcardIndexes = [];\r\n    const buffer = new BufferReader();\r\n    bytesToFind.forEach(v => {\r\n        if (v === '?') {\r\n            wildcardIndexes.push(buffer.length);\r\n            buffer.copyBuffer([0x00]);\r\n        } else {\r\n            buffer.copyBuffer(Array.isArray(v) ? v : [v]);\r\n        }\r\n    });\r\n\r\n    // set stuff up\r\n    const bytesToFindView = new Uint8Array(buffer.write())\r\n    const copyParser = new WailParser(parser.inBuffer);\r\n    const matchingFunctionIndexes = [];\r\n\r\n    const checkIfFunctionMatches = function ({ index: functionIndex, bytes: codeBytes }) {\r\n        let startIndex;\r\n        for (let i = 0; i < codeBytes.length; i++) {\r\n            if (codeBytes[i] === bytesToFindView[0]) {\r\n                let match = true;\r\n                startIndex = i;\r\n                for (let j = 1; j < bytesToFindView.length; j++) {\r\n                    if (codeBytes[i + j] !== bytesToFindView[j] && !wildcardIndexes.includes(j)) {\r\n                        match = false;\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                if (match) {\r\n                    matchingFunctionIndexes.push(functionIndex);\r\n                    wyff.logger.debug(`Found function using bytes`, { bytesToFindView, functionIndex, matchedBytes: codeBytes.subarray(startIndex, startIndex + bytesToFindView.length) });\r\n                }\r\n            }\r\n        }\r\n\r\n        return codeBytes;\r\n    }\r\n\r\n    // Parse and handle each individual function to see if the code bytes match\r\n    copyParser.addCodeElementParser(null, checkIfFunctionMatches);\r\n    copyParser.parse();\r\n\r\n    if (matchingFunctionIndexes.length === 0) {\r\n        wyff.logger.error(`Could not find function using bytes`, { bytesToFindView });\r\n        throw new Error(\"Could not find function using bytes\");\r\n    }\r\n\r\n    if (matchingFunctionIndexes.length > 1) {\r\n        wyff.logger.error(`Found multiple functions using bytes`, { bytesToFindView, matchingFunctionIndexes });\r\n        throw new Error(\"Found multiple functions using bytes\");\r\n    }\r\n\r\n    return matchingFunctionIndexes[0];\r\n}","export default function handleCombatPacket(message) {\r\n    // 68 + 71 dmg\r\n    const view = new DataView(message.buffer);\r\n    const dmg = view.getInt32(70, true)\r\n    wyff.logger.debug(`GOT HIT FOR ${dmg}`)\r\n\r\n}","import findFunctionUsingBytes from \"../find-function\";\r\nimport handleMessageByCommand from \"./received-hooks\";\r\n\r\nexport function decryptionFunctionHook(beginAddress, endAddress) {\r\n    // Using the beginAddress and endAddress, we can get the message payload\r\n    const length = endAddress - beginAddress;\r\n    const message = new Uint8Array(new Uint8Array(wasmMemory.buffer, beginAddress, length));\r\n\r\n    const first4Bytes = message.slice(4, 8);\r\n    const first4BytesUint32 = new Uint32Array(first4Bytes.buffer)[0];\r\n    let cmdNumber = first4BytesUint32;\r\n\r\n    handleMessageByCommand(cmdNumber, message);\r\n\r\n    // convert to ascii\r\n    const messageAscii = new TextDecoder(\"ascii\").decode(message);\r\n    wyff.logger.debug(`RECEIVED (cmd: ${cmdNumber} \\n%c${message.join(\"\\t\")}%c\\n%c${messageAscii}`, 'background: #c4e2ff; color: black;', '', 'background: #c4d0ff; color: black;', {\r\n        buffer: message,\r\n    });\r\n}\r\n\r\nexport function hookDecryptionFunction(parser, hookRef) {\r\n    const functionIndex = findFunctionUsingBytes(parser, [\r\n        OP_GET_LOCAL, VarUint32(0x02),\r\n        OP_I32_LOAD, VarUint32(0x02), VarUint32(36),\r\n        OP_I32_LOAD, 0x00, VarUint32(5),\r\n    ]);\r\n\r\n    wyff.logger.info(`Found decryption function`, { functionIndex });\r\n\r\n    parser.addCodeElementParser(parser._getAdjustedFunctionIndex(functionIndex), function ({ bytes }) {\r\n        const reader = new BufferReader(bytes);\r\n\r\n        // push the original function without the last END byte\r\n        reader.copyBuffer(bytes.subarray(0, bytes.length - 1));\r\n\r\n        /**\r\n         * At the very end of the decryption function,\r\n         * var0 is a memory address that contains the address of the beginning of the message payload.\r\n         * var1 is a memory address that contains the address of the end of the message payload.\r\n         */\r\n        reader.copyBuffer([ OP_GET_LOCAL ]);\r\n        reader.copyBuffer(VarUint32(0x00));\r\n        reader.copyBuffer([ OP_GET_LOCAL ]);\r\n        reader.copyBuffer(VarUint32(0x01));\r\n        reader.copyBuffer([ OP_CALL ]);\r\n        reader.copyBuffer(hookRef.varUint32());\r\n\r\n        reader.copyBuffer([ OP_END ]);\r\n\r\n        return reader.write();\r\n    });\r\n}","import handleCombatPacket from \"./combat\";\r\n\r\nexport default function handleMessageByCommand(cmdNumber, message) {\r\n    const cmds = {\r\n        260372: handleCombatPacket(message)\r\n    }\r\n\r\n    if (typeof cmds[cmdNumber] === 'undefined') {\r\n        return;\r\n    }\r\n\r\n    cmds[cmdNumber](message);\r\n}\r\n","export default function handleMovementPacket(message) {\r\n    const view = new DataView(message.buffer);\r\n\r\n    const cmdPacketLength = 4;\r\n    const unknownBytes = 13;\r\n    const movementOperationOffset = cmdPacketLength + unknownBytes;\r\n\r\n    const movementOperation = view.getUint8(movementOperationOffset);\r\n\r\n    wyff.logger.info(`movement operation: ${movementOperation}`);\r\n\r\n    const startOfMovementOperationArguments = cmdPacketLength + 18;\r\n    if (movementOperation === 1) {\r\n        // we are moving in a direction using movement keys\r\n        const angleOffset = startOfMovementOperationArguments;\r\n        const angle = view.getFloat32(angleOffset, true);\r\n\r\n        wyff.logger.info(`moving using movement keys: angle: ${angle}`);\r\n    } else if (movementOperation === 7) {\r\n        // we are moving to a specific location using the mouse\r\n        const x = view.getFloat32(startOfMovementOperationArguments, true);\r\n        const y = view.getFloat32(startOfMovementOperationArguments + 8, true);\r\n        const z = view.getFloat32(startOfMovementOperationArguments + 16, true);\r\n\r\n        wyff.logger.info(`moving using the mouse: x: ${x}, y: ${y}, z: ${z}`);\r\n    }\r\n\r\n    const startOfUnknownHeader = cmdPacketLength\r\n\r\n    wyff.logger.info(\r\n        `%c${message.slice(startOfUnknownHeader, startOfMovementOperationArguments - 4)},` +\r\n        `%c${message.slice(startOfMovementOperationArguments - 4, startOfMovementOperationArguments)},` +\r\n        `%c${message.slice(startOfMovementOperationArguments)}`,\r\n\r\n        'background: orange; color: black;',\r\n        'background: red; color: black;',\r\n        'background: yellow; color: black;',\r\n\r\n    );\r\n\r\n}","import { uint64ToUint8Array } from \"../../../shared/utils/bytes\";\r\nimport findFunctionUsingBytes from \"../find-function\";\r\nimport handleMessageByCommand from \"./sending-hooks\";\r\n\r\nexport function encryptionFunctionHook(ptr) {\r\n    /**\r\n     * Now we have the address of the beginning of the message payload\r\n     * var0+4 is an address that contains the address of the end of the message payload\r\n     */\r\n    const dataview = new DataView(wasmMemory.buffer);\r\n\r\n    const beginningOfMsgPtr = dataview.getUint32(ptr, true);\r\n    const endOfMsgPtr = dataview.getUint32(ptr + 4, true);\r\n\r\n    // calculate length using addresses\r\n    const messageLength = endOfMsgPtr - beginningOfMsgPtr;\r\n    // get the message\r\n    const message = new Uint8Array(new Uint8Array(wasmMemory.buffer, beginningOfMsgPtr, messageLength));\r\n\r\n    // get first 4 bytes of the message\r\n    const first4Bytes = message.slice(0, 4);\r\n    // convert to uint32\r\n    const first4BytesUint32 = new Uint32Array(first4Bytes.buffer)[0];\r\n    let cmdNumber = first4BytesUint32;\r\n    let isMessageEncrypted = first4Bytes[3] === 100;\r\n    if (isMessageEncrypted) {\r\n        // the command packet is encrypted\r\n        const secretnumber = 1684713472;\r\n        cmdNumber = first4BytesUint32 ^ secretnumber;\r\n\r\n        handleMessageByCommand(cmdNumber, message);\r\n    }\r\n\r\n    // convert to ascii\r\n    const messageAscii = new TextDecoder(\"ascii\").decode(message);\r\n\r\n    wyff.logger.debug(`SENDING (cmd: ${cmdNumber} (${isMessageEncrypted ? 'E' : 'NE'}))\\n%c${message.join(\"\\t\")}%c\\n%c${messageAscii}`, 'background: #c4ffcd; color: black;', '', 'background: #a7facd; color: black;', {\r\n        buffer: message,\r\n    });\r\n}\r\n\r\nexport function hookEncryptionFunction(parser, hookRef) {\r\n    const functionIndex = findFunctionUsingBytes(parser, [\r\n        /**\r\n         * These bytes are like the very beginning of the encryption function\r\n         */\r\n        OP_GET_LOCAL, VarUint32(0x00),\r\n        OP_I32_LOAD, VarUint32(0x02), VarUint32(4),\r\n        OP_TEE_LOCAL, VarUint32(0x02),\r\n        OP_GET_LOCAL, VarUint32(0x00),\r\n        OP_I32_LOAD, VarUint32(0x02), VarUint32(0x00),\r\n        OP_TEE_LOCAL, VarUint32(0x03),\r\n        OP_I32_SUB,\r\n        OP_SET_LOCAL, VarUint32(0x06),\r\n        OP_I32_CONST, 9,\r\n        OP_SET_LOCAL, VarUint32(0x07),\r\n    ]);\r\n\r\n    wyff.logger.info(`Found encryption function`, { functionIndex });\r\n\r\n    parser.addCodeElementParser(parser._getAdjustedFunctionIndex(functionIndex), function ({ bytes }) {\r\n        const reader = new BufferReader(bytes);\r\n\r\n        /**\r\n         * At the beginning of the encryption function, var0 is a memory address\r\n         * that contains the address of the beginning of the message payload.\r\n         */\r\n\r\n        // push the first arg of the function onto the stack\r\n        reader.copyBuffer([ OP_GET_LOCAL ]);\r\n        reader.copyBuffer(VarUint32(0x00));\r\n        // call the hook function\r\n        reader.copyBuffer([ OP_CALL ]);\r\n        reader.copyBuffer(hookRef.varUint32());\r\n\r\n        // push the rest of the function\r\n        reader.copyBuffer(bytes);\r\n        return reader.write();\r\n    });\r\n}","import handleMovementPacket from \"./movement\";\r\n\r\nexport default function handleMessageByCommand(cmdNumber, message) {\r\n    const cmds = {\r\n        1028: handleMovementPacket,\r\n    }\r\n\r\n    if (typeof cmds[cmdNumber] === 'undefined') {\r\n        return;\r\n    }\r\n\r\n    cmds[cmdNumber](message);\r\n}","import { decryptionFunctionHook, hookDecryptionFunction } from \"./hooks/decryption.js\";\r\nimport { encryptionFunctionHook, hookEncryptionFunction } from \"./hooks/encryption.js\";\r\n\r\nfunction instrumentResults(imports, binary) {\r\n    return { imports, binary };\r\n}\r\n\r\nfunction importFunction(parser, name, params, returnType) {\r\n    // Add a new function into the wasm binary\r\n    // 'env' is referring to the import object name that contains\r\n    // all of our imports. \r\n    return parser.addImportEntry({\r\n        moduleStr: \"env\",\r\n        fieldStr: name,\r\n        kind: \"func\",\r\n        type: parser.addTypeEntry({\r\n            form: \"func\",\r\n            params: params,\r\n            returnType: returnType\r\n        })\r\n    });\r\n}\r\n\r\nexport default function instrumentBinary(binary) {\r\n    const parser = new WailParser(binary);\r\n    const imports = {\r\n        env: {\r\n            encryptionHook: encryptionFunctionHook,\r\n            decryptionHook: decryptionFunctionHook\r\n        }\r\n    };\r\n\r\n    // Import all functions up front so the function indexes are known\r\n    const encryptionHookRef = importFunction(parser, \"encryptionHook\", [\"i32\"]);\r\n    const decryptionHookRef = importFunction(parser, \"decryptionHook\", [\"i32\", \"i32\"]);\r\n\r\n    try {\r\n        hookEncryptionFunction(parser, encryptionHookRef);\r\n    } catch (e) {\r\n        wyff.logger.error(`error hooking encryption function`);\r\n        wyff.logger.error(e);\r\n    }\r\n\r\n    try {\r\n        hookDecryptionFunction(parser, decryptionHookRef);\r\n    } catch (e) {\r\n        wyff.logger.error(`error hooking decryption function`);\r\n        wyff.logger.error(e);\r\n    }\r\n\r\n    // parse and write the new binary\r\n    parser.parse();\r\n    return instrumentResults(imports, parser.write());\r\n}","import { mergeDeep } from \"../../shared/utils/merge\";\r\nimport instrumentBinary from \"../instrument\";\r\n\r\nfunction createHookFunction(original) {\r\n    return async function(bufferSource, importObject = {}) {\r\n        wyff.logger.debug(\"WebAssembly.instantiate() intercepted\");\r\n\r\n        const instrumentResults = instrumentBinary(bufferSource);\r\n        if (instrumentResults.imports) {\r\n            importObject = mergeDeep(importObject, instrumentResults.imports);\r\n        }\r\n\r\n        return original(instrumentResults.binary, importObject);\r\n    };\r\n}\r\n\r\nexport default function hookInstantiate() {\r\n    const oldFunction = WebAssembly.instantiate;\r\n    const hook = createHookFunction(oldFunction);\r\n    window.WebAssembly.instantiate = hook;\r\n}\r\n","async function getSourceBuffer() {\r\n    if (sourceObj instanceof Promise) {\r\n        const res = await sourceObj;\r\n        return res.arrayBuffer()\r\n    } else if (sourceObj instanceof Response) {\r\n        return await sourceObj.arrayBuffer();\r\n    } else {\r\n        throw new Error(\"Got unexpected object type as first argument to WebAssembly.instantiateStreaming\");\r\n    }\r\n}\r\n\r\nfunction createHookFunction(original) {\r\n    return async function(sourceObj, importObject = {}) {\r\n        wyff.logger.debug(\"WebAssembly.instantiateStreaming() intercepted\");\r\n        const buffer = await getSourceBuffer(sourceObj);\r\n        return WebAssembly.instantiate(buffer, importObject);\r\n    };\r\n}\r\n\r\nexport default function hookInstantiateStreaming() {\r\n    const oldFunction = WebAssembly.instantiateStreaming;\r\n    const hook = createHookFunction(oldFunction);\r\n    window.WebAssembly.instantiateStreaming = hook;\r\n}\r\n","import Log from \"../shared/utils/log.js\";\r\nimport removeDebuggerProtection from \"./debugger-protection.js\";\r\nimport { MemoryWrapper } from \"./memory/index.js\";\r\nimport hookWASMTriggerFunctions from \"./wasm-trigger/index.js\";\r\n\r\nconst logger = new Log();\r\nwindow.wyff = {\r\n    logger,\r\n};\r\n\r\nsetInterval(() => {\r\n    if (window.wasmMemory !== undefined) {\r\n        window.MemoryWrapper = new MemoryWrapper(wasmMemory);\r\n    }\r\n})\r\n\r\nremoveDebuggerProtection();\r\nhookWASMTriggerFunctions();","export default class Log {\r\n    constructor(infoWriter, debugWriter, errorWriter) {\r\n        this.infoWriter = infoWriter || console.log;\r\n        this.debugWriter = debugWriter || console.debug;\r\n        this.errorWriter = errorWriter || console.error;\r\n\r\n        const prefixStyle = [\r\n            \"font-size: 1.6em\",\r\n            \"font-weight: bold\",\r\n            \"text-transform: uppercase\",\r\n        ].join(\";\");\r\n\r\n        this.info = this.infoWriter.bind(console, \"%c[WYFF]%c INFO\\t%s\", prefixStyle, \"\");\r\n        this.debug = this.debugWriter.bind(console, \"%c[WYFF]%c DEBUG\\t%s\", prefixStyle, \"\");\r\n        this.error = this.errorWriter.bind(console, \"%c[WYFF]%c ERROR\\t%s\", prefixStyle, \"\");\r\n    }\r\n}\r\n","export default function removeDebuggerProtection(logger) {\r\n    wyff.logger.debug(`hooking function to remove debugger protection`);\r\n\r\n    window._Function = Function;\r\n    window.Function = function() {\r\n        window.c = (a) => (a ? () => () => {} : null);\r\n        wyff.logger.debug(`debugger protection removed`);\r\n        const fn = window._Function.apply(this, arguments);\r\n        window.Function = window._Function;\r\n        return fn;\r\n    };\r\n}","import hookInstantiate from \"./instantiate.js\";\r\nimport hookInstantiateStreaming from \"./instantiateStreaming.js\";\r\n\r\nexport default function hookWASMTriggerFunctions() {\r\n    wyff.logger.info(`hooking WASM functions`);\r\n\r\n    // We need to hook into these two functions to capture when the wasm binary is about to be loaded\r\n    // in and parsed by the browser. We can modify the binary before it reaches the browser engine.\r\n    //\r\n    // These hooks end up calling the instrumentBinary() function\r\n    hookInstantiate();\r\n    hookInstantiateStreaming();\r\n}"],"names":["toHex","i","parseInt","toString","padStart","MemoryWrapper","constructor","memory","this","getMemoryType","memType","Uint8Array","Uint16Array","Uint32Array","BigInt64Array","Float32Array","Float64Array","Error","alignedMemory","memTypeStr","buffer","unalignedMemory","getMemorySize","length","search","searchValue","lowerBound","upperBound","result","realLowerBound","realUpperBound","memSize","realParam","charCodeAt","tempBuf","Array","isArray","split1","trim","matchAll","split2","split","console","error","shift","searchResults","bytesSequence","results","hitAddr","wyff","logger","info","count","bytesSeq","debug","match","push","readBytes","address","size","intSize","asAscii","bytes","Int8Array","Int32Array","map","byte","String","fromCharCode","join","isObject","item","mergeDeep","target","sources","source","key","Object","assign","findFunctionUsingBytes","parser","bytesToFind","wildcardIndexes","BufferReader","forEach","v","copyBuffer","bytesToFindView","write","copyParser","WailParser","inBuffer","matchingFunctionIndexes","addCodeElementParser","index","functionIndex","codeBytes","startIndex","j","includes","matchedBytes","subarray","parse","handleCombatPacket","message","dmg","DataView","getInt32","decryptionFunctionHook","beginAddress","endAddress","wasmMemory","first4Bytes","slice","cmdNumber","cmds","handleMessageByCommand","messageAscii","TextDecoder","decode","handleMovementPacket","view","movementOperation","getUint8","cmdPacketLength","angleOffset","angle","getFloat32","x","y","startOfMovementOperationArguments","z","encryptionFunctionHook","ptr","dataview","beginningOfMsgPtr","getUint32","messageLength","first4BytesUint32","isMessageEncrypted","importFunction","name","params","returnType","addImportEntry","moduleStr","fieldStr","kind","type","addTypeEntry","form","createHookFunction","original","async","bufferSource","importObject","instrumentResults","binary","imports","env","encryptionHook","decryptionHook","encryptionHookRef","decryptionHookRef","hookRef","OP_GET_LOCAL","VarUint32","OP_I32_LOAD","OP_TEE_LOCAL","OP_I32_SUB","OP_SET_LOCAL","OP_I32_CONST","_getAdjustedFunctionIndex","reader","OP_CALL","varUint32","hookEncryptionFunction","e","OP_END","hookDecryptionFunction","instrumentBinary","getSourceBuffer","sourceObj","Promise","arrayBuffer","Response","infoWriter","debugWriter","errorWriter","log","prefixStyle","bind","window","setInterval","undefined","_Function","Function","c","a","fn","apply","arguments","hook","WebAssembly","instantiate","hookInstantiate","instantiateStreaming"],"sourceRoot":""}