{"version":3,"file":"content-script.js","mappings":";;;;;;;;;;;;;;AAAA;AACA;AACA;;AAEe;;AAEf;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,qCAAqC,wBAAwB,IAAI,KAAK,GAAG,eAAe;AACxF;;AAEA;AACA;AACA;AACA;AACA;AACA,0EAA0E;AAC1E;AACA,gCAAgC,2BAA2B;AAC3D,yCAAyC,EAAE;AAC3C;;AAEA;AACA;AACA,oEAAoE,oBAAoB;AACxF;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,IAAI;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,0DAA0D,aAAa;AACvE;AACA;AACA;;AAEA;;;;;;;;;;;;;;;AClEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,QAAQ,iBAAiB,SAAS;AACpF;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA,mEAAmE,4CAA4C,iBAAiB,SAAS;AACzI;;;;;;;;;;;;;;;AClBO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,mFAAmF,MAAM;AACzF,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA,2EAA2E,EAAE,OAAO,EAAE,OAAO,EAAE;AAC/F;;AAEA;;AAEA;;AAEA;AACA,iCAAiC,uEAAuE;AACxG,aAAa,oFAAoF;AACjG,aAAa,8EAA8E;AAC3F,aAAa,2CAA2C;AACxD,4BAA4B,SAAS;;AAErC,6BAA6B,aAAa;AAC1C,0BAA0B,aAAa;AACvC,2BAA2B,aAAa;AACxC,6BAA6B,aAAa;AAC1C;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AClDO;AACP,oDAAoD,eAAe,wBAAwB,aAAa;AACxG;AACA,KAAK;AACL;;AAEO;AACP,sDAAsD,eAAe,2BAA2B,aAAa;AAC7G;AACA,KAAK;AACL;;AAEO;AACP,iEAAiE,eAAe,uBAAuB,aAAa;AACpH;AACA,KAAK;AACL;;AAEO;AACP,yDAAyD,eAAe,0BAA0B,aAAa;AAC/G;AACA,KAAK;AACL;;;;;;;;;;;;;;ACtBe;;AAEf;AACA;;AAEA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;;ACfe;AACf;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qDAAqD;AACrD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,wDAAwD;AACxD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC9CsF;AACmB;AAC6D;;AAEvJ;AACf;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,+BAA+B,6BAA6B;AAC5D;AACA;AACA,uCAAuC,8BAA8B;AACrE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kDAAkD,4BAA4B,QAAQ,aAAa,yBAAyB,aAAa,6BAA6B,aAAa;AACnL;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;;AAEA,+BAA+B,+BAA+B;AAC9D;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,+EAA+E,aAAa;AAC5F,+EAA+E,aAAa;AAC5F;AACA;;AAEA,qDAAqD,qEAAqE,QAAQ,qCAAqC,yBAAyB,aAAa,8DAA8D,aAAa;AACxR;AACA;AACA;AACA,uFAAuF,eAAe;AACtG,gBAAgB;;AAEhB;AACA,+BAA+B,+BAA+B;AAC9D;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,iDAAiD,4BAA4B,QAAQ,aAAa,yBAAyB,aAAa,6BAA6B,aAAa;AAClL;AACA;AACA,aAAa;;AAEb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,IAAI;AAC9D;AACA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA,wBAAwB,oBAAoB;AAC5C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,wBAAwB,oBAAoB;AAC5C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;AC9Le;AACf;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACNe;AACf;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAgB,0CAA0C;;AAE1D;AACA;AACA;;AAEA,mDAAmD,wCAAwC;AAC3F;AACA,4BAA4B,sBAAsB;AAClD;AACA;AACA;AACA,oCAAoC,4BAA4B;AAChE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,0EAA0E,6IAA6I;AACvN;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,uEAAuE,iBAAiB;AACxF;AACA;;AAEA;AACA,wEAAwE,0CAA0C;AAClH;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;;;;ACtE8C;AACe;;AAE9C;AACf;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kCAAkC;AAClC;;AAEA;AACA;AACA;AACA;AACA;AACA,gBAAgB,8BAA8B;;AAE9C;AACA;AACA,oDAAoD,KAAK;;AAEzD;AACA;AACA;AACA;AACA;;AAEA,iCAAiC;;AAEjC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,2BAA2B,uDAAS;;AAEpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;;AAEA,sCAAsC,oBAAoB;AAC1D;AACA;AACA;AACA;;AAEA,eAAe,uDAAS;AACxB;AACA,SAAS;AACT;AACA;;;;;;;;;;;;;;;AC9FmD;;AAEnD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEe;AACf,8BAA8B;AAC9B;;AAEA;AACA;AACA;AACA;AACA;;AAEA,+CAA+C;AAC/C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,8EAA8E,qBAAqB;AACnG;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mCAAmC,2DAAc;AACjD;AACA;;AAEA;;;;;;;;;;;;;;;;ACvDgD;AACb;;AAEpB,mCAAmC,gDAAU;;AAE5D;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wEAAwE,UAAU;;AAElF,oEAAoE,OAAO;AAC3E;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,4BAA4B,gCAAgC;AAC5D;AACA,gCAAgC,qBAAqB;AACrD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,qFAAqF,sCAAsC;AAC3H;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,mBAAmB,QAAQ,aAAa,yBAAyB,aAAa,6BAA6B,aAAa;AACzL;AACA;AACA,YAAY;AACZ;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;;;AC5HmC;;AAEpB,mCAAmC,gDAAU;AAC5D;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wEAAwE,UAAU;;AAElF,oEAAoE,OAAO;AAC3E;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,4BAA4B,kBAAkB;AAC9C;AACA,gCAAgC,qBAAqB;AACrD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,qFAAqF,sCAAsC;AAC3H;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,WAAW,GAAG,gCAAgC,QAAQ,mBAAmB,QAAQ,aAAa,yBAAyB,aAAa,6BAA6B,aAAa;AAC5N;AACA,YAAY;AACZ;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;;;;;;;;;;;;;;;;ACnJ+D;AAC5B;;AAEpB,wBAAwB,gDAAU;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,2CAA2C,gFAAgF,KAAK,WAAW;;AAE3I;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mEAAmE,oCAAoC,GAAG,iBAAiB;;AAE3H;AACA;AACA;AACA,mCAAmC,iBAAiB,iBAAiB,2CAA2C;AAChH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,sEAAsE,kBAAkB;AACxF,+CAA+C,OAAO;AACtD;;AAEA;AACA;;AAEA;AACA,oEAAoE,MAAM,EAAE,KAAK,EAAE,IAAI;;AAEvF;AACA;;AAEA;AACA,wEAAwE,oBAAoB;AAC5F;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;;;;ACxFmC;;AAE5B;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEe,+BAA+B,gDAAU;;AAExD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,yCAAyC;AACzC;;AAEA;AACA;AACA;AACA,mCAAmC,gBAAgB;AACnD;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,6CAA6C,UAAU,eAAe,0BAA0B;AAChG;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,6CAA6C,sBAAsB,UAAU,UAAU;AACvF;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,2CAA2C,QAAQ;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACrSuC;;AAEhC;;AAEP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,gCAAgC,wBAAwB;AACxD;AACA;;AAEA;AACA;AACA;;AAEA,gCAAgC,wBAAwB;AACxD;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,gFAAgF,EAAE;AAClF;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,oCAAoC,wBAAwB;AAC5D;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA,wBAAwB,0BAA0B;AAClD;AACA;AACA,gCAAgC,yDAAK,UAAU,IAAI,YAAY;AAC/D;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;;AAEA,wBAAwB,mBAAmB;AAC3C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;;AAEA,+DAA+D,gCAAgC;AAC/F;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,UAAU;AACV;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,wBAAwB,UAAU;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC9LO;AACP;AACA;AACA,oBAAoB,yBAAyB;AAC7C;AACA;AACA;AACA;;;;;;;;;;;;;;ACPe;AACf;AACA;;;;;;;;;;;;;;ACFA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAEM;AACf;AACA;AACA;AACA;AACA;;AAEA;AACA,uCAAuC,OAAO;AAC9C;;AAEA;AACA,wCAAwC,OAAO;AAC/C;;AAEA;AACA,wCAAwC,OAAO;AAC/C;AACA;;;;;;;;;;;;;;;;AC5BA;AACA;AACA;AACA,aAAa;AACb;AACO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;;AAEA;AACA;AACA;AACA,0DAA0D,WAAW;AACrE;AACA,cAAc;AACd,wCAAwC,oBAAoB;AAC5D;AACA;AACA;;AAEA;AACA;;;;;;UC9BA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;;;;;;;;;;;ACNkC;AAC2C;AACrB;AACoB;AACA;AACnB;AACP;AACe;AACjE;AACkD;AACE;AACgB;AACpE;;AAEA;AACA;AACA,0BAA0B,qDAAG;AAC7B,sCAAsC,8DAAkB;AACxD,4CAA4C,4EAAwB;AACpE,oCAAoC,+DAAgB;AACpD,kCAAkC,2DAAc;AAChD,mCAAmC,4DAAe;;AAElD;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA,iCAAiC,2DAAa;;AAE9C;AACA;AACA,oDAAoD,iCAAiC;AACrF;;AAEA;AACA;AACA,oDAAoD,iCAAiC;AACrF;;AAEA;;AAEA;AACA,kDAAkD,4EAAgB;AAClE,sDAAsD,+EAAoB;AAC1E,sDAAsD,+EAAoB;AAC1E;AACA,gDAAgD,+EAAS;AACzD;AACA;;AAEA;AACA","sources":["webpack:///./src/content-script/hooks/emscripten.js","webpack:///./src/content-script/hooks/packets/received/chat.js","webpack:///./src/content-script/hooks/packets/received/movement.js","webpack:///./src/content-script/hooks/packets/received/player.js","webpack:///./src/content-script/hooks/remove-debugger-protection.js","webpack:///./src/content-script/hooks/wasm-triggers.js","webpack:///./src/content-script/hooks/websocket.js","webpack:///./src/content-script/instrumenter/defs/wasm-import-function.js","webpack:///./src/content-script/instrumenter/function-finder.js","webpack:///./src/content-script/instrumenter/index.js","webpack:///./src/content-script/instrumenter/instruments/base.js","webpack:///./src/content-script/instrumenter/instruments/decryption.js","webpack:///./src/content-script/instrumenter/instruments/encryption.js","webpack:///./src/content-script/instrumenter/instruments/hook-emval.js","webpack:///./src/content-script/instrumenter/instruments/memory.js","webpack:///./src/content-script/memory/index.js","webpack:///./src/utils/base64.js","webpack:///./src/utils/hex.js","webpack:///./src/utils/log.js","webpack:///./src/utils/merge.js","webpack:///webpack/bootstrap","webpack:///webpack/runtime/define property getters","webpack:///webpack/runtime/hasOwnProperty shorthand","webpack:///webpack/runtime/make namespace object","webpack:///./src/content-script/index.js"],"sourcesContent":["function insertIntoString(main_string, ins_string = '', pos = 0) {\n    return main_string.slice(0, pos) + ins_string + main_string.slice(pos);\n}\n\nexport default class EmscriptenHooks {\n\n    init() {\n        this._hookNewFunc();\n        this._hookAsyncLoad();\n        // this._hookBrowserObj();\n    }\n\n    _hookNewFunc() {\n        const original = window.newFunc;\n\n        window.wyff.callMethodCallback = function(handle, name, args) {\n            wyff.logger.debug(`got ${handle.constructor.name}->${name}(${args.join(',')})`);\n        }\n\n        window.newFunc = function(constructor, argumentList) {\n            if (constructor.name === 'Function') {\n                const functionBodyIndex = argumentList.length - 1;\n                const functionBody = argumentList[functionBodyIndex];\n                const matchArguments = functionBody.match(/var arg[0-9]+/) || [];\n                const findReturnIndex = functionBody.indexOf('var rv ='); // find the moment when the handle() is about to be called.\n                const argString = [];\n                for (let i = 0; i < matchArguments.length; i++) {\n                    argString.push(`arg${i}`);\n                }\n\n                if (argString.length > 1) {\n                    const newFunctionBody = insertIntoString(functionBody, `\n                    window.wyff.callMethodCallback(handle, name, [${argString.join(',')}]);\n                    `, findReturnIndex);\n\n                    argumentList[functionBodyIndex] = newFunctionBody;\n                }\n            }\n\n            return original(constructor, argumentList);\n        }\n    }\n\n    _hookAsyncLoad() {\n        const original = window.asyncLoad;\n        window.asyncLoad = function(url, onload, onerror, noRunDep) {\n            if (url.indexOf('screenfwc.bin') > -1) {\n                const originalOnload = onload;\n                onload = function(...args) {\n                    wyff.logger.info(`loaded ${url}`);\n                    debugger;\n                    return originalOnload(...args);\n                }\n            }\n            return original(url, onload, onerror, noRunDep);\n        }\n    }\n\n    // _hookBrowserObj() {\n    //     const original = window.Browser.mainLoop.runIter;\n    //     window.Browser.mainLoop.runIter = function(...args) {\n    //         wyff.logger.info(`starting an iteration: ${args[0].name}`);\n    //         return original(...args);\n    //     }\n    // }\n\n}","export function handleChatPacket(msg) {\n    const view = new DataView(msg.buffer);\n    const cmdPacket = view.getUint32(0, true);\n    const chatMessageLength = view.getUint32(4, true);\n    const message = new TextDecoder(\"ascii\").decode(msg.slice(8, 8 + chatMessageLength));\n    const afterMessageUnknownBytes = 5;\n    const whoDidIt = view.getBigUint64(8 + chatMessageLength + afterMessageUnknownBytes, true);\n    // rest is unknown\n    wyff.logger.info(`[received chat] message: \"${message}\", who did it: ${whoDidIt}`);\n}\n\nexport function handleChatIndicatorPacket(msg) {\n    const view = new DataView(msg.buffer);\n    const cmdPacket = view.getUint32(0, true);\n    const chatIndicator = view.getUint8(4, true);\n    const whoDidIt = view.getBigUint64(5, true);\n    // rest is unknown\n    wyff.logger.info(`[received chat indicator] chat indicator: \"${chatIndicator ? 'chatting' : 'NOT chatting'}\", who did it: ${whoDidIt}`);\n}","export function handleMovementPacket(msg) {\n    const view = new DataView(msg.buffer);\n    const cmdPacketLength = 4;\n    const unknownBytes = 13;\n    const movementOperationOffset = cmdPacketLength + unknownBytes;\n    const startOfMovementOperationArguments = cmdPacketLength + 18;\n    let endOfMovementOperationArguments;\n\n    const movementOperation = view.getUint8(movementOperationOffset, true);\n\n    if (movementOperation === 1) {\n        // we are moving in a direction using movement keys\n        const angleOffset = startOfMovementOperationArguments;\n        const angle = view.getFloat32(angleOffset, true);\n        endOfMovementOperationArguments = angleOffset + 8;\n\n        wyff.logger.info(`[received movement] moving using movement keys: angle: ${angle}`);\n    } else if (movementOperation === 7) {\n        // we are moving to a specific location using the mouse\n        const x = view.getFloat32(startOfMovementOperationArguments, true);\n        const y = view.getFloat32(startOfMovementOperationArguments + 8, true);\n        const z = view.getFloat32(startOfMovementOperationArguments + 16, true);\n        endOfMovementOperationArguments = startOfMovementOperationArguments + 24;\n\n        wyff.logger.info(`[received movement] moving using the mouse: x: ${x}, y: ${y}, z: ${z}`);\n    }\n\n    const startOfUnknownHeader = cmdPacketLength;\n\n    const whoDidIt = view.getBigUint64(endOfMovementOperationArguments, true);\n\n    wyff.logger.info(\n        `[received movement] %c${msg.slice(startOfUnknownHeader, startOfMovementOperationArguments - 4)},` +\n        `%c${msg.slice(startOfMovementOperationArguments - 4, startOfMovementOperationArguments)},` +\n        `%c${msg.slice(startOfMovementOperationArguments, endOfMovementOperationArguments)},` +\n        `%c${msg.slice(endOfMovementOperationArguments)}` +\n        `%c - who did it: ${whoDidIt}`,\n\n        'background: orange; color: black;',\n        'background: red; color: black;',\n        'background: cyan; color: black;',\n        'background: yellow; color: black;',\n        '',\n    );\n}\n\nexport function handlePersonLeavingOrEnterViewPacket(msg) {\n    const view = new DataView(msg.buffer);\n    const cmdPacketLength = 4;\n    \n}\n","export function handleFashionChangePacket(msg) {\n    wyff.logger.info(`[received fashion change] %c${msg.join(\"\\t\")}`, 'background: orange; color: black;', {\n        buffer: msg\n    });\n}\n\nexport function handleEquipmentChangePacket(msg) {\n    wyff.logger.info(`[received equipment change] %c${msg.join(\"\\t\")}`, 'background: chocolate; color: black;', {\n        buffer: msg\n    });\n}\n\nexport function handleEquipmentVisibilityChangePacket(msg) {\n    wyff.logger.info(`[received equipment visibility change] %c${msg.join(\"\\t\")}`, 'background: coral; color: black;', {\n        buffer: msg\n    });\n}\n\nexport function handleKickFromServerPacket(msg) {\n    wyff.logger.info(`[received kick from server???] %c${msg.join(\"\\t\")}`, 'background: lightred; color: black;', {\n        buffer: msg\n    });\n}","export default class RemoveDebuggerProtection {\n\n    do() {\n        wyff.logger.debug(`hooking function to remove debugger protection`);\n\n        window._Function = Function;\n        window.Function = function() {\n            window.c = (a) => (a ? () => () => {} : null);\n            wyff.logger.info(`debugger protection removed`);\n            const fn = window._Function.apply(this, arguments);\n            window.Function = window._Function;\n            return fn;\n        };\n    }\n\n}","export default class HookWasmTriggers {\n    do(instrumenterCallback) {\n        if (typeof instrumenterCallback !== \"function\") {\n            throw new Error(\"Expected instrumenterCallback to be a function\");\n        }\n\n        this.instrumenterCallback = instrumenterCallback;\n\n        wyff.logger.info(`hooking WASM functions`);\n        // We need to hook into these two functions to capture when the wasm binary is about to be loaded\n        // in and parsed by the browser. We can modify the binary before it reaches the browser engine.\n        this.hookInstantiate();\n        this.hookInstantiateStreaming();\n    }\n\n    hookInstantiate() {\n        const oldFunction = WebAssembly.instantiate;\n        const hook = (bufferSource, importObject = {}) => {\n            wyff.logger.debug(\"WebAssembly.instantiate() intercepted\");\n            const instrumentResults = this.instrumenterCallback(bufferSource, importObject);\n            return oldFunction(instrumentResults.binary, instrumentResults.imports);\n        };\n\n        window.WebAssembly.instantiate = hook;\n    }\n\n    hookInstantiateStreaming() {\n        const hook = async (sourceObj, importObject = {}) => {\n            wyff.logger.debug(\"WebAssembly.instantiateStreaming() intercepted\");\n            const buffer = await this._getSourceBuffer(sourceObj);\n            return WebAssembly.instantiate(buffer, importObject);\n        }\n\n        window.WebAssembly.instantiateStreaming = hook;\n    }\n\n    async _getSourceBuffer() {\n        if (sourceObj instanceof Promise) {\n            const res = await sourceObj;\n            return res.arrayBuffer()\n        } else if (sourceObj instanceof Response) {\n            return await sourceObj.arrayBuffer();\n        } else {\n            throw new Error(\"Got unexpected object type as first argument to WebAssembly.instantiateStreaming\");\n        }\n    }\n}","import { handleChatIndicatorPacket, handleChatPacket } from \"./packets/received/chat\";\nimport { handleMovementPacket, handlePersonLeavingOrEnterViewPacket } from \"./packets/received/movement\";\nimport { handleEquipmentChangePacket, handleEquipmentVisibilityChangePacket, handleFashionChangePacket, handleKickFromServerPacket } from \"./packets/received/player\";\n\nexport default class WebsocketHooks {\n    websocketsCreated = [];\n    lastMessage = null;\n    possibleIndexes = [];\n\n    init() {\n        var self = this;\n        var ws = window.WebSocket;\n\n        const fakeConstructor = function(a, b) {\n            var that = b ? new ws(a, b) : new ws(a);\n            self.onWebsocketCreated(that);\n            return that;\n        }\n\n        window.WebSocket = fakeConstructor;\n    }\n\n    onWebsocketCreated(ws) {\n        this.websocketsCreated.push(ws);\n\n        ws.addEventListener('close', (...args) => {\n            this.websocketsCreated = this.websocketsCreated.filter((x) => x !== ws);\n            wyff.logger.debug(`[ws] CLOSED`, args);\n            // debugger;\n        });\n        \n        ws.addEventListener('message', (msg) => {\n            const message = new Uint8Array(msg.data);\n            // first byte = magic byte (always 184)\n            // byte 2-5 = length of the message (32 bit)\n            // byte 6-9 = CRC-32 checksum\n\n            const afterSkippedBytes = message.slice(9);\n\n            const decryptedMessage = this.decryptionRoutine(afterSkippedBytes);\n            const messageAscii = new TextDecoder(\"ascii\").decode(decryptedMessage);\n\n            // const separatorSequence = [0,0,0,1,0,0,0,1];\n            // const individualCommands = [];\n            // let currentCommandStartIndex = 0;\n            \n            // for (let i = 0; i < decryptedMessage.length; i++) {\n            //     if (decryptedMessage[i] === separatorSequence[0]) {\n            //         let found = true;\n            //         for (let j = 1; j < separatorSequence.length; j++) {\n            //             if (decryptedMessage[i+j] !== separatorSequence[j]) {\n            //                 found = false;\n            //                 break;\n            //             }\n            //         }\n\n            //         if (found) {\n            //             individualCommands.push(decryptedMessage.slice(currentCommandStartIndex, i));\n            //             currentCommandStartIndex = i + separatorSequence.length;\n            //         }\n            //     }\n            // }\n\n            // if (individualCommands.length === 0) {\n            //     individualCommands.push(decryptedMessage);\n            // }\n\n            wyff.logger.debug(`[ws] RECEIVED\\n%c${decryptedMessage.join(\"\\t\")}%c\\n%c${messageAscii}`, 'background: #c4e2ff; color: black;', '', 'background: #c4d0ff; color: black;', {\n                decryptedMessage: decryptedMessage,\n                encryptedMessage: message,\n                // individualCommands: individualCommands,\n            });\n\n            // const separatorSequenceTabbed = separatorSequence.join(\"\\t\");\n            // let decryptedMessagesExtraColors = [];\n            // let decryptedAllCommandsInt8 = [];\n            // let decryptedAllCommandsAscii = [];\n            // let individualCommandHeaders = [];\n\n            // for (let i = 0; i < individualCommands.length; i++) {\n            //     const decryptedCommandInt8 = individualCommands[i];\n            //     const decryptedCommandAscii = new TextDecoder(\"ascii\").decode(decryptedCommandInt8);\n\n            //     const view = new DataView(decryptedCommandInt8.buffer);\n            //     const cmdPacket = view.getUint32(0, true);\n            //     individualCommandHeaders.push(cmdPacket);\n\n            //     decryptedAllCommandsInt8.push(decryptedCommandInt8.join(\"\\t\"));\n            //     decryptedAllCommandsAscii.push(decryptedCommandAscii);\n\n            //     if (i > 0) {\n            //         decryptedMessagesExtraColors.push('background: #ffcccb; color: black;');\n            //         decryptedMessagesExtraColors.push('background: #c4e2ff; color: black;');\n            //     }\n            // }\n\n            // wyff.logger.debug(`[ws] RECEIVED\\n%c${decryptedAllCommandsInt8.join(\"%c\" + separatorSequenceTabbed + \"%c\")}%c\\n%c${decryptedAllCommandsAscii.join(\"\\n\")}`, 'background: #c4e2ff; color: black;', ...decryptedMessagesExtraColors, '', 'background: #c4d0ff; color: black;', {\n            //     buffer: decryptedMessage,\n            //     encryptedMessage: message,\n            //     // individualCommands: individualCommands,\n            //     // individualCommandHeaders: individualCommandHeaders.map(x => `0x${x.toString(16)}`),\n            // });\n\n            this._handleReceivedPacket(decryptedMessage);\n            // for (let i = 0; i < individualCommands.length; i++) {\n            //     this._handleReceivedPacket(individualCommands[i]);\n            // }\n\n            this.lastMessage = message;\n        });\n\n        const originalSend = ws.send;\n        ws.send = (data) => {\n            const message = new Uint8Array(data);\n            // first byte = magic byte (always 31)\n            // byte 2-5 = length of the message (32 bit)\n            // byte 6-9 = CRC-32 checksum\n            const afterSkippedBytes = message.slice(9);\n\n            const decryptedMessage = this.encryptionRoutine(afterSkippedBytes);\n            const messageAscii = new TextDecoder(\"ascii\").decode(decryptedMessage);\n\n            wyff.logger.debug(`[ws] SENDING\\n%c${decryptedMessage.join(\"\\t\")}%c\\n%c${messageAscii}`, 'background: #c4ffcd; color: black;', '', 'background: #a7facd; color: black;', {\n                decryptedMessage: decryptedMessage,\n                originalMessage: message,\n            });\n\n            originalSend.call(ws, message);\n        };\n\n        // Patch every single function on the WebSocket object so we can intercept all function calls\n        for (let key in ws) {\n            if (typeof ws[key] === 'function') {\n                ws[key] = new Proxy(ws[key], {\n                    apply: (target, thisArg, argumentsList) => {\n                        if (key === 'close') {\n                            // debugger;\n                        }\n                        wyff.logger.debug(`[ws] CALLING ${key}`, argumentsList);\n                        return target.apply(thisArg, argumentsList);\n                    }\n                });\n            }\n        }\n    }\n\n    encryptionRoutine(message) {\n        const result = new Uint8Array(message.length);\n        for (var i = 0; i < message.length; i++) {\n            let xorKeyIndex = (i+1) & (wyff.encryptionXorKey.length-1);\n            result[i] = message[i] ^ wyff.encryptionXorKey[xorKeyIndex];\n        }\n        return result;\n    }\n\n    decryptionRoutine(message) {\n        const result = new Uint8Array(message.length);\n        for (var i = 0; i < message.length; i++) {\n            let xorKeyIndex = (i+1) & (wyff.decryptionXorKey.length-1);\n            result[i] = message[i] ^ wyff.decryptionXorKey[xorKeyIndex];\n        }\n        return result;\n    }\n\n    async _handleReceivedPacket(msg) {\n        const view = new DataView(msg.buffer);\n        const cmdPacket = view.getUint32(0, true);\n\n        const packetDictionary = {\n            /* none of this is right anymore. */\n\n            // // 0x646a8400: handleClientInitialInfoPacket,\n            // 0x641ab004: handleMovementPacket,\n            // 0x646ab44e: handleChatIndicatorPacket,\n            // 0x646ab400: handleChatPacket,\n            // // 0x646a843d: handlePersonLoggingInIntoView,\n            // 0x646a8402: handlePersonLeavingOrEnterViewPacket,\n            // 0x646a842a: handleFashionChangePacket,\n            // 0x646a8427: handleEquipmentChangePacket,\n            // 0x646a8418: handleEquipmentVisibilityChangePacket,\n        }\n\n        if (packetDictionary[cmdPacket]) {\n            packetDictionary[cmdPacket](msg);\n        }\n    }\n\n    getActiveWebsocket() {\n        return this.websocketsCreated.find((ws) => ws.readyState === 1);\n    }\n}","export default class WasmImportFunction {\n    constructor (name, params, func) {\n        this.name = name;\n        this.params = params;\n        this.func = func;\n    }\n}","export default class FunctionFinder {\n    constructor(parser) {\n        this.wailParser = parser;\n    }\n\n    _getBytesPatternWithWildcards(bytesToFind) {\n        // Convert bytesToFind to a Uint8Array and mark where the wildcards are\n        const wildcardIndexes = [];\n        const buffer = new BufferReader();\n        bytesToFind.forEach(v => {\n            if (v === '?') {\n                wildcardIndexes.push(buffer.length);\n                buffer.copyBuffer([0x00]);\n            } else {\n                buffer.copyBuffer(Array.isArray(v) ? v : [v]);\n            }\n        });\n        \n        return {\n            bytes: new Uint8Array(buffer.write()),\n            wildcardIndexes,\n        };\n    }\n\n    findFunction(bytesToFind) {\n        const { bytes: bytesToFindView, wildcardIndexes } = this._getBytesPatternWithWildcards(bytesToFind);\n\n        // get copy of wail parser without any modifications\n        const copyParser = new WailParser(this.wailParser.inBuffer);\n        const matchingFunctionIndexes = [];\n\n        const checkIfFunctionMatches = function ({ index: functionIndex, bytes: codeBytes }) {\n            let startIndex;\n            for (let i = 0; i < codeBytes.length; i++) {\n                if (codeBytes[i] === bytesToFindView[0]) {\n                    let match = true;\n                    startIndex = i;\n                    for (let j = 1; j < bytesToFindView.length; j++) {\n                        if (codeBytes[i + j] !== bytesToFindView[j] && !wildcardIndexes.includes(j)) {\n                            match = false;\n                            break;\n                        }\n                    }\n\n                    if (match) {\n                        matchingFunctionIndexes.push(functionIndex);\n                        wyff.logger.debug(`Found function using bytes`, { functionBytes: codeBytes, bytesToFindView, functionIndex, matchedBytes: codeBytes.subarray(startIndex, startIndex + bytesToFindView.length) });\n                    }\n                }\n            }\n\n            return codeBytes;\n        }\n\n        // Parse and handle each individual function to see if the code bytes match\n        copyParser.addCodeElementParser(null, checkIfFunctionMatches);\n        copyParser.parse();\n\n        if (matchingFunctionIndexes.length === 0) {\n            wyff.logger.error(`Could not find function using bytes`, { bytesToFindView });\n            throw new Error(\"Could not find function using bytes\");\n        }\n\n        if (matchingFunctionIndexes.length > 1) {\n            wyff.logger.error(`Found multiple functions using bytes`, { bytesToFindView, matchingFunctionIndexes });\n            throw new Error(\"Found multiple functions using bytes\");\n        }\n\n        return this.wailParser._getAdjustedFunctionIndex(matchingFunctionIndexes[0]);\n    }\n}","import { mergeDeep } from \"../../utils/merge\";\nimport WasmImportFunction from \"./defs/wasm-import-function\";\n\nexport default class BinaryInstrumenter {\n    wailParser = null;\n\n    constructor() {\n        this.instruments = [];\n    }\n\n    add(name, instrument) {\n        if (instrument && typeof instrument !== 'object') {\n            throw new Error(\"instrument must be an object\");\n        }\n\n        this.instruments[name] = instrument;\n    }\n\n    run(bufferSource, imports = {}) {\n        this.wailParser = new WailParser(bufferSource);\n\n        /**\n         * We need to know all of our imports before we start calling\n         * our instruments because function indexes shift as we\n         * import new functions.\n         */\n        const { finalImports, newImportRefs } = this._initAndCollectImports(bufferSource, imports);\n\n        // now call each instrument's instrument function\n        for (const name in this.instruments) {\n            wyff.logger.info(`Running instrument: ${name}`);\n\n            const instrument = this.instruments[name];\n            if (typeof instrument.instrument === 'function') {\n                instrument.instrument(newImportRefs);\n            }\n        }\n\n        this.wailParser.parse(); // kicks off everything\n\n        return {\n            binary: this.wailParser.write(),\n            imports: finalImports,\n        };\n    }\n\n    _initAndCollectImports(bufferSource, originalImports) {\n        let finalImports = originalImports;\n        let newImportRefs = {};\n\n        for (const name in this.instruments) {\n            const instrument = this.instruments[name];\n\n            instrument.init(this.wailParser, bufferSource, originalImports);\n\n            // what imports are you replacing\n            finalImports = mergeDeep(finalImports, instrument.replacedImports);\n\n            // what imports are you creating\n            const newImports = instrument.addedImports;\n            for (const [name, importDef] of Object.entries(newImports)) {\n                newImportRefs[name] = this.addFunctionImport(name, importDef.params, importDef.returnType);\n\n                finalImports[instrument.PARENT_NEW_IMPORTS_KEY] = finalImports[instrument.PARENT_NEW_IMPORTS_KEY] || {};\n                finalImports[instrument.PARENT_NEW_IMPORTS_KEY][name] = importDef.callable;\n            }\n        }\n\n        return { finalImports, newImportRefs };\n    }\n\n    addFunctionImport(name, params, returnType) {\n        return this.wailParser.addImportEntry({\n            moduleStr: \"env\",\n            fieldStr: name,\n            kind: \"func\",\n            type: this.wailParser.addTypeEntry({\n                form: \"func\",\n                params: params,\n                returnType: returnType\n            })\n        });\n    }\n\n    _mergeImports(startingImports = {}, newImportDefs = {}) {\n        const newImports = {};\n        for (const [name, importDef] of Object.entries(newImportDefs)) {\n            newImports[name] = importDef.func;\n        }\n\n        return mergeDeep(startingImports, {\n            env: newImports\n        });\n    }\n}","import FunctionFinder from \"../function-finder.js\";\n\nfunction findKeyFromFunctionName(imports, functionName) {\n    const keys = Object.keys(imports);\n    const index = keys.findIndex(x => imports[x].name === functionName);\n    if (index === -1) {\n        return null;\n    }\n\n    return keys[index];\n}\n\nexport default class Instrument {\n    PARENT_IMPORTS_KEY = \"a\"; // all emscripten imports are under imports['a']\n    PARENT_NEW_IMPORTS_KEY = \"env\" // all new imports will live under imports['env']\n\n    wailParser = null;\n    binarySource = null;\n    imports = {};\n    replacedImports = {};\n    addedImports = {}\n\n    init(wailParser, binarySource, imports = {}) {\n        this.wailParser = wailParser;\n        this.binarySource = binarySource;\n        this.imports = imports;\n    }\n\n    hookImport(originalFunctionName, hookFunction) {\n        const key = findKeyFromFunctionName(this.imports[this.PARENT_IMPORTS_KEY], originalFunctionName);\n        if (!key) {\n            throw new Error(`could not find wasm import using function name ${originalFunctionName}`);\n        }\n        const originalFunction = this.imports[this.PARENT_IMPORTS_KEY][key];\n        const newFunction = function(...args) {\n            return hookFunction(originalFunction, ...args);\n        }\n\n        this.replacedImports[this.PARENT_IMPORTS_KEY] = this.replacedImports[this.PARENT_IMPORTS_KEY] || {}\n        this.replacedImports[this.PARENT_IMPORTS_KEY][key] = newFunction;\n    }\n\n    addImport(name, params, returnType, callable) {\n        this.addedImports[name] = {\n            params,\n            returnType,\n            callable\n        };\n    }\n\n    findFunctionUsingBytes(bytesPattern) {\n        const functionFinder = new FunctionFinder(this.wailParser);\n        return functionFinder.findFunction(bytesPattern);\n    }\n\n}","import FunctionFinder from \"../function-finder\";\nimport Instrument from \"./base.js\";\n\nexport default class DecryptionInstrument extends Instrument {\n\n    init(wailParser, bufferSource, imports) {\n        super.init(wailParser, bufferSource, imports);\n\n        // this.addImport(\"decryptionHook\", [\"i32\", \"i32\"], null, this.decryptionHook.bind(this));\n    }\n\n    instrument(importRefs) {\n        // find the decryption function\n        const funcIndex = this.findFunctionUsingBytes([\n            OP_GET_LOCAL, VarUint32(0x02),\n            OP_I32_LOAD, VarUint32(0x02), VarUint32(36),\n            OP_I32_LOAD, 0x00, VarUint32(5),\n        ]);\n\n        wyff.logger.info(`instrumenting the decryption function @ func${funcIndex}`);\n\n        this.wailParser.addCodeElementParser(funcIndex, function ({ bytes }) {\n            const reader = new BufferReader(bytes);\n\n            const codeBytesWithoutEnd = bytes.subarray(0, bytes.length - 1);\n\n            // look through the code bytes until we find:\n            //   local.get $var1\n            //   i32.const 1\n            //   i32.add\n            //   local.tee $var1\n            //   i32.const 31\n            //   i32.and\n            //\n            // We are trying to find this sequence because the xor key is 2 bytes from the end of this sequence.\n            const sequence = [\n                OP_GET_LOCAL, 1,\n                OP_I32_CONST, 1,\n                OP_I32_ADD,\n                OP_TEE_LOCAL, 1,\n                OP_I32_CONST, 31,\n                OP_I32_AND,\n            ];\n\n            let found = false;\n            for (let i = 0; i < codeBytesWithoutEnd.length; i++) {\n                found = true;\n                for (let j = 0; j < sequence.length; j++) {\n                    if (codeBytesWithoutEnd[i + j] !== sequence[j]) {\n                        found = false;\n                        break;\n                    }\n                }\n\n                if (found) {\n                    // from here, the xor key is 2 bytes from the end of the sequence.\n                    const startingPosition = i + sequence.length + 1;\n\n                    // pull 4 bytes from the starting position\n                    const xorKeyReader = new BufferReader(codeBytesWithoutEnd.subarray(startingPosition, startingPosition+4));\n                    // read the varuint32 from the 4 bytes and add 1. this puts us at the starting position of the xor key.\n                    const xorKeyMemoryAddressStart = xorKeyReader.readVarUint32();\n                    wyff.logger.info(`[decrypt function] found xor key @ address 0x${xorKeyMemoryAddressStart.toString(16)}`);\n                    // record the address for later. the binary hasn't even run yet, so we can't pull the xor key yet.\n                    wyff.decryptionXorKeyMemoryAddress = xorKeyMemoryAddressStart;\n\n                    break;\n                }\n            }\n\n            if (!found) {\n                wyff.logger.error(\"could not find the memory address storing the xor key\");\n            }\n\n            reader.copyBuffer(codeBytesWithoutEnd);\n\n            // /**\n            //  * At the very end of the decryption function,\n            //  * var0 is a memory address that contains the address of the beginning of the message payload.\n            //  * var1 is a memory address that contains the address of the end of the message payload.\n            //  * \n            //  * Send those two addresses to our decryption hook.\n            //  */\n            // reader.copyBuffer([ OP_GET_LOCAL ]);\n            // reader.copyBuffer(VarUint32(0x00));\n            // reader.copyBuffer([ OP_GET_LOCAL ]);\n            // reader.copyBuffer(VarUint32(0x01));\n            // reader.copyBuffer([ OP_CALL ]);\n            // reader.copyBuffer(importRefs.decryptionHook.varUint32());\n\n            reader.copyBuffer([ OP_END ]);\n\n            return reader.write();\n        });\n    }\n\n    /** same reason this is commented out as encryption.js */\n \n    // decryptionHook(beginAddress, endAddress) {\n    //     // Using the beginAddress and endAddress, we can get the message payload from memory\n    //     const length = endAddress - beginAddress;\n    //     const message = new Uint8Array(new Uint8Array(wasmMemory.buffer, beginAddress, length));\n    \n    //     // const first4Bytes = message.slice(4, 8);\n    //     // const first4BytesUint32 = new Uint32Array(first4Bytes.buffer)[0];\n    //     // let cmdNumber = first4BytesUint32;\n    //     // this.handleMessageByCommand(cmdNumber, message);\n    \n    //     // convert to ascii\n    //     const messageAscii = new TextDecoder(\"ascii\").decode(message);\n    \n    //     wyff.logger.debug(`[decrypt hook] [old] RECEIVED\\n%c${message.join(\"\\t\")}%c\\n%c${messageAscii}`, 'background: #c4e2ff; color: black;', '', 'background: #c4d0ff; color: black;', {\n    //         buffer: message,\n    //         originalMessage: wyff.websocketHooks.lastMessage,\n    //     });\n    // }\n\n    // handleMessageByCommand(cmdNumber, message) {\n    //     switch (cmdNumber) {\n    //         // case 260372: return handleCombatPacket(message)\n    //     }\n\n    //     return null;\n    // }\n}","import Instrument from \"./base.js\";\n\nexport default class EncryptionInstrument extends Instrument {\n    init(wailParser, bufferSource, imports) {\n        super.init(wailParser, bufferSource, imports);\n\n        // this.addImport(\"encryptionHook\", [\"i32\"], null, this.encryptionHook.bind(this));\n    }\n\n    instrument(importRefs) {\n        const funcIndex = this.findFunctionUsingBytes([\n            /**\n             * These bytes are the very beginning of the encryption function\n             */\n             OP_GET_LOCAL, VarUint32(0x00),\n             OP_I32_LOAD, VarUint32(0x02), VarUint32(4),\n             OP_TEE_LOCAL, VarUint32(0x02),\n             OP_GET_LOCAL, VarUint32(0x00),\n             OP_I32_LOAD, VarUint32(0x02), VarUint32(0x00),\n             OP_TEE_LOCAL, VarUint32(0x03),\n             OP_I32_SUB,\n             OP_SET_LOCAL, VarUint32(0x06),\n             OP_I32_CONST, 9,\n             OP_SET_LOCAL, VarUint32(0x07),\n        ]);\n\n        wyff.logger.info(`instrumenting the encryption function @ func${funcIndex}`);\n\n        this.wailParser.addCodeElementParser(funcIndex, function ({ bytes }) {\n            const reader = new BufferReader(bytes);\n\n            // look through the code bytes until we find:\n            //   i32.load8_u\n            //   local.tee $var2\n            //   local.get $var5\n            //   i32.const 1\n            //   i32.add\n            //   local.tee $var5\n            //   i32.const 31\n            //   i32.and\n\n            const sequence = [\n                OP_I32_LOAD8_U, 0, 0,\n                OP_TEE_LOCAL, 2,\n                OP_GET_LOCAL, 5,\n                OP_I32_CONST, 1,\n                OP_I32_ADD,\n                OP_TEE_LOCAL, 5,\n                OP_I32_CONST, 31,\n                OP_I32_AND,\n            ];\n\n            let found = false;\n            for (let i = 0; i < bytes.length; i++) {\n                found = true;\n                for (let j = 0; j < sequence.length; j++) {\n                    if (bytes[i + j] !== sequence[j]) {\n                        found = false;\n                        break;\n                    }\n                }\n\n                if (found) {\n                    // from here, the xor key is 2 bytes from the end of the sequence.\n                    const startingPosition = i + sequence.length + 1;\n\n                    // pull 4 bytes from the starting position\n                    const xorKeyReader = new BufferReader(bytes.subarray(startingPosition, startingPosition+4));\n                    // read the varuint32 from the 4 bytes and add 1. this puts us at the starting position of the xor key.\n                    const xorKeyMemoryAddressStart = xorKeyReader.readVarUint32();\n                    wyff.logger.info(`[encrypt function] found xor key @ address 0x${xorKeyMemoryAddressStart.toString(16)}`);\n                    // record the address for later. the binary hasn't even run yet, so we can't pull the xor key yet.\n                    wyff.encryptionXorKeyMemoryAddress = xorKeyMemoryAddressStart;\n                    break;\n                }\n            }\n\n            if (!found) {\n                wyff.logger.error(`[encrypt function] could not find xor key`);\n            }\n    \n            // /**\n            //  * At the beginning of the encryption function, var0 is a memory address\n            //  * that contains the address of the beginning of the message payload.\n            //  */\n    \n            // // push the first arg of the function onto the stack\n            // reader.copyBuffer([ OP_GET_LOCAL ]);\n            // reader.copyBuffer(VarUint32(0x00));\n            // // call the hook function\n            // reader.copyBuffer([ OP_CALL ]);\n            // reader.copyBuffer(importRefs.encryptionHook.varUint32());\n    \n            // push the rest of the function\n            reader.copyBuffer(bytes);\n            return reader.write();\n        });\n    }\n\n    /** this code below was when i didnt know how to get the xor key. so i just pulled the message from the encrypt function w/o decrypting anything */\n\n    // encryptionHook(ptr) {\n    //     /**\n    //      * Now we have the address of the beginning of the message payload\n    //      * var0+4 is an address that contains the address of the end of the message payload\n    //      */\n    //     const dataview = new DataView(window.wasmMemory.buffer);\n    \n    //     const beginningOfMsgPtr = dataview.getUint32(ptr, true);\n    //     const endOfMsgPtr = dataview.getUint32(ptr + 4, true);\n    \n    //     // calculate length using addresses\n    //     const messageLength = endOfMsgPtr - beginningOfMsgPtr;\n    //     // get the message\n    //     const message = new Uint8Array(new Uint8Array(window.wasmMemory.buffer, beginningOfMsgPtr, messageLength));\n    \n    //     // get first 4 bytes of the message\n    //     const first4Bytes = message.slice(0, 4);\n    //     // convert to uint32\n    //     const first4BytesUint32 = new Uint32Array(first4Bytes.buffer)[0];\n    //     let cmdNumber = first4BytesUint32;\n    //     let isMessageEncrypted = first4Bytes[3] === 100;\n    //     if (isMessageEncrypted) {\n    //         // the command packet is encrypted\n    //         const secretnumber = 1684713472;\n    //         cmdNumber = first4BytesUint32 ^ secretnumber;\n    \n    //         this._handleMessageByCommand(cmdNumber, message);\n    //     }\n    \n    //     // convert to ascii\n    //     const messageAscii = new TextDecoder(\"ascii\").decode(message);\n    \n    //     wyff.logger.debug(`SENDING (cmd: ${cmdNumber} (${isMessageEncrypted ? 'E' : 'NE'}))\\n%c${message.join(\"\\t\")}%c\\n%c${messageAscii}`, 'background: #c4ffcd; color: black;', '', 'background: #a7facd; color: black;', {\n    //         buffer: message,\n    //     });\n    // }\n\n    // _handleMessageByCommand(cmdNumber, message) {\n    //     switch (cmdNumber) {\n    //         case 1028: return handleMovementPacket(message);\n    //     }\n\n    //     return;\n    // }\n\n\n}","import { base64ToArrayBuffer } from \"../../../utils/base64.js\";\nimport Instrument from \"./base.js\";\n\nexport default class HookEmval extends Instrument {\n    init(wailParser, bufferSource, imports) {\n        super.init(wailParser, bufferSource, imports);\n        // this.hookImport(\"__emval_get_property\", this.emvalGetProperty.bind(this));\n        // this.hookImport(\"__emval_call_method\", this.emvalCallMethod.bind(this));\n        // this.hookImport(\"__emval_call_void_method\", this.emvalCallVoidMethod.bind(this));\n        // this.hookImport(\"_emscripten_async_wget_data\", this.emscriptenAsyncWgetData.bind(this));\n        // this.hookImport(\"_emscripten_memcpy_big\", this.emscriptenMemcpyBig.bind(this));\n    }\n\n    emvalGetProperty(og, handle, name) {\n        const actualHandle = emval_handles.allocated[handle].value;\n        const actualName = emval_handles.allocated[name].value;\n\n        wyff.logger.debug(`get property: ${actualHandle.constructor ? actualHandle.constructor.name : typeof actualHandle} -> ${actualName}`);\n\n        // tricking flyff into thinking the game window is smaller than it really is. funsies.\n        // if (actualHandle instanceof Window) {\n        //     let modifiedValue;\n        //     if (actualName === \"innerWidth\") {\n        //         modifiedValue = window.innerWidth - 250;\n        //     } else if (actualName === \"innerHeight\") {\n        //         modifiedValue = window.innerHeight - 250;\n        //     }\n\n        //     if (typeof modifiedValue !== 'undefined') {\n        //         emval_handles.allocated[handle].value = {\n        //             [actualName]: modifiedValue,\n        //         };\n\n        //         const returnValue = og(handle, name);\n        //         emval_handles.allocated[handle].value = actualHandle;\n        //         return returnValue;\n        //     }\n        // }\n\n        return og(handle, name);\n    }\n\n    emvalCallMethod(og, caller, handle, name, ...args) {\n        wyff.logger.debug(`call method`, args);\n        return og(caller, handle, name, ...args);\n    }\n\n    emvalCallVoidMethod(og, caller, handle, methodName, args) {\n        const actualMethodName = getStringOrSymbol(methodName);\n        const actualCaller = emval_methodCallers[caller];\n        const actualHandle = emval_handles.get(handle);\n    \n        wyff.logger.info(`__emval_call_void_method() intercepted ${actualHandle.value.constructor.name}.${actualMethodName}()`);\n\n        // if (actualMethodName === \"fillText\" || actualMethodName === \"strokeText\") {\n        //     const dataview = new DataView(wasmMemory.buffer);\n        //     const handleIndex = dataview.getUint8(args);\n        //     wyff.logger.info(`${actualMethodName}() intercepted ${emval_handles.allocated[handleIndex].value}`);\n        // }\n    \n        return og(caller, handle, methodName, args);\n    }\n\n    emscriptenAsyncWgetData(og, url, arg, onload, onerror) {\n        // if (UTF8ToString(url).indexOf('en.bin') > -1) {\n        //     debugger;\n        // }\n\n        wyff.logger.info(`_emscripten_async_wget_data() intercepted ${UTF8ToString(url)}`);\n        wyff.logger.info(`onload func index: ${onload}`);\n        wyff.logger.info(`wasm table thing`, window.getWasmTableEntry(onload));\n\n        return og(url, arg, onload, onerror);\n    }\n\n    emscriptenMemcpyBig(og, dest, src, num) {\n        // wyff.logger.info(`_emscripten_memcpy_big() intercepted ${dest} ${src} ${num}`);\n\n        const memBeingCopied = new Uint8Array(wasmMemory.buffer, src, num);\n        const asciiRepresentation = new TextDecoder(\"ascii\").decode(memBeingCopied);\n\n        // if (asciiRepresentation.indexOf('model') > -1) {\n        //     wyff.logger.info(`_emscripten_memcpy_big() intercepted ${asciiRepresentation}`);\n        //     debugger;\n        // }\n\n        return og(dest, src, num);\n    }\n}","import Instrument from \"./base.js\";\n\nexport class Sequence {\n    sequence = [];\n    recordedAddressAccess = [];\n\n    constructor(sequence) {\n        this.sequence = sequence;\n        this.recordedAddressAccess = sequence.map(() => []);\n    }\n}\n\nexport default class MemoryInstrument extends Instrument {\n\n    /**\n     * The idea behind this is: it is possible for us to be in the middle\n     * of every single read/write memory operation. (thx Cetus)\n     * Because of that, we can watch specific addresses and break.\n     * We can also watch for specific sequences of read/writes, which is super\n     * powerful for finding specific operations.\n     */\n    watchAddresses = {\n        // \"address\" => { \"read\": bool, \"write\": bool }\n    };\n\n    // watchForWrittenMemorySequences = {\n        // \"[purpose]\": new Sequence([], ),\n    // };\n\n    init(wailParser, bufferSource, imports) {\n        super.init(wailParser, bufferSource, imports);\n\n        this._addImports();\n\n        this.writeEntrypointI32 = wailParser.addFunctionEntry({\n            type: wailParser.addTypeEntry({\n                form: \"func\",\n                params: [ \"i32\", \"i32\", \"i32\" ],\n            })\n        });\n\n        this.lastWriteInfo = {\n            \"address\": wailParser.addGlobalEntry({\n                globalType: {\n                    contentType: \"i32\",\n                    mutability: true,\n                },\n                initExpr: [ OP_I32_CONST, VarUint32(0x00), OP_END ]\n            }),\n\n            \"value_i32\": wailParser.addGlobalEntry({\n                globalType: {\n                    contentType: \"i32\",\n                    mutability: true,\n                },\n                initExpr: [ OP_I32_CONST, VarUint32(0x00), OP_END ]\n            }),\n        };\n    }\n\n    _addImports() {\n        this.addImport(\"readMemoryHook\", [\"i32\", \"i32\", \"i32\"], \"i32\", this.readMemoryHook.bind(this));\n        this.addImport(\"writeMemoryHook\", [\"i32\", \"i32\", \"i32\"], null, this.writeMemoryHook.bind(this));\n    }\n\n    instrument(importRefs) {\n        this.wailParser.addCodeEntry(this.writeEntrypointI32, {\n            locals: [],\n            code: [\n                OP_GET_LOCAL, VarUint32(0),\n                OP_SET_GLOBAL, this.lastWriteInfo.address.varUint32(),\n                OP_GET_LOCAL, VarUint32(1),\n                OP_SET_GLOBAL, this.lastWriteInfo.value_i32.varUint32(),\n                \n                OP_GET_LOCAL, VarUint32(0),\n                OP_GET_LOCAL, VarUint32(1),\n                OP_GET_LOCAL, VarUint32(2),\n                OP_CALL, importRefs.writeMemoryHook.varUint32(),\n                OP_END\n            ]\n        });\n\n        this.wailParser.addInstructionParser(OP_I32_LOAD,     this.readMemoryInstrument(importRefs.readMemoryHook));\n        this.wailParser.addInstructionParser(OP_I64_LOAD,     this.readMemoryInstrument(importRefs.readMemoryHook));\n        this.wailParser.addInstructionParser(OP_F32_LOAD,     this.readMemoryInstrument(importRefs.readMemoryHook));\n        this.wailParser.addInstructionParser(OP_F64_LOAD,     this.readMemoryInstrument(importRefs.readMemoryHook));\n        this.wailParser.addInstructionParser(OP_I32_LOAD8_S,  this.readMemoryInstrument(importRefs.readMemoryHook));\n        this.wailParser.addInstructionParser(OP_I32_LOAD8_U,  this.readMemoryInstrument(importRefs.readMemoryHook));\n        this.wailParser.addInstructionParser(OP_I32_LOAD16_S, this.readMemoryInstrument(importRefs.readMemoryHook));\n        this.wailParser.addInstructionParser(OP_I32_LOAD16_U, this.readMemoryInstrument(importRefs.readMemoryHook));\n        this.wailParser.addInstructionParser(OP_I64_LOAD8_S,  this.readMemoryInstrument(importRefs.readMemoryHook));\n        this.wailParser.addInstructionParser(OP_I64_LOAD8_U,  this.readMemoryInstrument(importRefs.readMemoryHook));\n        this.wailParser.addInstructionParser(OP_I64_LOAD16_S, this.readMemoryInstrument(importRefs.readMemoryHook));\n        this.wailParser.addInstructionParser(OP_I64_LOAD16_U, this.readMemoryInstrument(importRefs.readMemoryHook));\n        this.wailParser.addInstructionParser(OP_I64_LOAD32_S, this.readMemoryInstrument(importRefs.readMemoryHook));\n        this.wailParser.addInstructionParser(OP_I64_LOAD32_U, this.readMemoryInstrument(importRefs.readMemoryHook));\n\n        // this.wailParser.addInstructionParser(OP_I32_STORE,   this.writeMemoryInstrument(importRefs.writeMemoryHook));\n        // this.wailParser.addInstructionParser(OP_I64_STORE,   this.writeMemoryInstrument(importRefs.writeMemoryHook));\n        // this.wailParser.addInstructionParser(OP_F32_STORE,   this.writeMemoryInstrument(importRefs.writeMemoryHook));\n        // this.wailParser.addInstructionParser(OP_F64_STORE,   this.writeMemoryInstrument(importRefs.writeMemoryHook));\n        // this.wailParser.addInstructionParser(OP_I32_STORE8,  this.writeMemoryInstrument(importRefs.writeMemoryHook));\n        // this.wailParser.addInstructionParser(OP_I32_STORE16, this.writeMemoryInstrument(importRefs.writeMemoryHook));\n        // this.wailParser.addInstructionParser(OP_I64_STORE8,  this.writeMemoryInstrument(importRefs.writeMemoryHook));\n        // this.wailParser.addInstructionParser(OP_I64_STORE16, this.writeMemoryInstrument(importRefs.writeMemoryHook));\n        // this.wailParser.addInstructionParser(OP_I64_STORE32, this.writeMemoryInstrument(importRefs.writeMemoryHook));\n\n        // this.wailParser.addInstructionParser(OP_SIMD, this.simdInstrCallback);\n        // this.wailParser.addInstructionParser(OP_ATOMIC, this.atomicInstrCallback);\n    }\n\n    readMemoryInstrument(importFunc) {\n        return function (instrBytes) {\n            const reader = new BufferReader(instrBytes);\n\n            const opcode = reader.readUint8();\n            const flags = reader.readVarUint32();\n            const offset = reader.readVarUint32();\n\n            let pushSizeImmediate;\n            let arg;\n\n            switch (opcode) {\n                case OP_I32_LOAD8_S:\n                case OP_I32_LOAD8_U:\n                case OP_I64_LOAD8_S:\n                case OP_I64_LOAD8_U:\n                    pushSizeImmediate = VarUint32(1);\n                    break;\n                case OP_I32_LOAD16_S:\n                case OP_I32_LOAD16_U:\n                case OP_I64_LOAD16_S:\n                case OP_I64_LOAD16_U:\n                    pushSizeImmediate = VarUint32(2);\n                    break;\n                case OP_I32_LOAD:\n                case OP_F32_LOAD:\n                case OP_I64_LOAD32_S:\n                case OP_I64_LOAD32_U:\n                    pushSizeImmediate = VarUint32(4);\n                    break;\n                case OP_I64_LOAD:\n                case OP_F64_LOAD:\n                    pushSizeImmediate = VarUint32(8);\n                    break;\n                case OP_SIMD:\n                    arg = instrBytes[1];\n                    switch(arg) {\n                        case SIMD_V128_LOAD8_SPLAT:\n                            pushSizeImmediate = VarUint32(1);\n                            break;\n                        case SIMD_V128_LOAD16_SPLAT:\n                            pushSizeImmediate = VarUint32(2);\n                            break;\n                        case SIMD_V128_LOAD32_ZERO:\n                        case SIMD_V128_LOAD32_SPLAT:\n                            pushSizeImmediate = VarUint32(4);\n                            break;\n                        case SIMD_V128_LOAD8X8_S:\n                        case SIMD_V128_LOAD8X8_U:\n                        case SIMD_V128_LOAD16X4_S:\n                        case SIMD_V128_LOAD16X4_U:\n                        case SIMD_V128_LOAD32X2_S:\n                        case SIMD_V128_LOAD32X2_U:\n                        case SIMD_V128_LOAD64_SPLAT:\n                        case SIMD_V128_LOAD64_ZERO:\n                            pushSizeImmediate = VarUint32(8);\n                            break;\n                        case SIMD_V128_LOAD:\n                            pushSizeImmediate = VarUint32(16);\n                            break;\n                    }\n                    break;\n                case OP_ATOMIC:\n                    arg = instrBytes[1];\n                    switch(arg) {\n                        case ARG_I32_ATOMIC_LOAD:\n                        case ARG_I64_ATOMIC_LOAD_32U:\n                            pushSizeImmediate = VarUint32(4);\n                            break;\n                        case ARG_I64_ATOMIC_LOAD:\n                            pushSizeImmediate = VarUint32(8);\n                            break;\n                        case ARG_I32_ATOMIC_LOAD_8U:\n                        case ARG_I64_ATOMIC_LOAD_8U:\n                            pushSizeImmediate = VarUint32(1);\n                            break;\n                        case ARG_I32_ATOMIC_LOAD_16U:\n                        case ARG_I64_ATOMIC_LOAD_16U:\n                            pushSizeImmediate = VarUint32(2);\n                            break;\n                        default:\n                            throw new Error(\"Bad atomic argument in readMemoryInstrument()\");\n                    }\n                    break;\n                default:\n                    throw new Error(\"Bad opcode in readMemoryInstrument()\");\n            }\n\n            reader.copyBuffer([ OP_I32_CONST ]);\n            reader.copyBuffer(pushSizeImmediate);\n            reader.copyBuffer([ OP_I32_CONST ]);\n            reader.copyBuffer(VarUint32(offset));\n            reader.copyBuffer([ OP_CALL ]);\n            reader.copyBuffer(importFunc.varUint32());\n            reader.copyBuffer(instrBytes);\n\n            return reader.write();\n        }\n    }\n\n    writeMemoryInstrument(importFunc) {\n        return (instrBytes) => {\n            const reader = new BufferReader();\n\n            reader.copyBuffer([ OP_I32_CONST ]);\n            reader.copyBuffer(VarUint32(instrBytes[2] || 0));\n            reader.copyBuffer([ OP_CALL ]);\n            reader.copyBuffer(this.writeEntrypointI32.varUint32());\n            \n            reader.copyBuffer([ OP_GET_GLOBAL ])\n            reader.copyBuffer(this.lastWriteInfo.address.varUint32());\n            reader.copyBuffer([ OP_GET_GLOBAL ])\n            reader.copyBuffer(this.lastWriteInfo.value_i32.varUint32());\n            reader.copyBuffer(instrBytes);\n\n            return reader.write();\n        };\n    }\n\n    addAddressWatch(address, read = true, write = true, handler = null) {\n        this.watchAddresses[address] = { read, write, handler };\n    }\n\n    readMemoryHook(baseAddress, loadSize, loadOffset) {\n        const startAddress = baseAddress + loadOffset;\n        const endAddress = startAddress + loadSize;\n        for (let i = startAddress; i < endAddress; i++) {\n            const watch = this.watchAddresses[i];\n            if (watch && watch.read) {\n                const handler = watch.handler;\n                if (handler) {\n                    handler(i);\n                } else {\n                    wyff.logger.info(`Read ${loadSize} bytes from 0x${startAddress.toString(16)}`);\n                }\n            }\n        }\n\n        return baseAddress;\n    }\n\n    writeMemoryHook(baseAddress, i32_value, offset) {\n        const address = baseAddress + offset;\n        const watch = this.watchAddresses[address];\n        if (watch && watch.write) {\n            const handler = watch.handler;\n            if (handler) {\n                handler(address, i32_value);\n            } else {\n                wyff.logger.info(`Write to ${address.toString(16)} = value ${i32_value}`);\n            }\n        }\n\n        // const index = this.sequence.indexOf(i32_value);\n        // if (index !== -1) {\n        //     if (index === 0) {\n        //         this.recorded[0].push(address);\n        //     } else {\n        //         // the previous ones should have already been recorded then.\n        //         let eliminated = false;\n        //         for (let i = index - 1; i >= 0; i--) {\n        //             const shouldBeAddress = address - (index-i);\n        //             if (!this.recorded[i] || this.recorded[i].indexOf(shouldBeAddress) === -1) {\n        //                 // noooo!\n        //                 eliminated = true;\n        //                 break;\n        //             }\n        //         }\n\n        //         if (!eliminated) {\n        //             this.recorded[index].push(address);\n        //             if (index === this.sequence.length - 1) {\n        //                 wyff.logger.info(\"woo\", address - this.sequence.length);\n        //             }\n        //         }\n        //     }\n        // }\n    }\n\n    clearHistory() {\n        this.recorded = this.sequence.map(() => []);\n    }\n}","import toHex from \"../../utils/hex.js\";\n\nexport class MemoryWrapper {\n\n    constructor(memory) {\n        this.memory = memory;\n    }\n\n    getMemoryType(memType) {\n        switch (memType) {\n            case \"i8\":\n            case \"ascii\":\n            case \"bytes\":\n                return Uint8Array;\n            case \"i16\":\n            case \"utf-8\":\n                return Uint16Array;\n            case \"i32\":\n                return Uint32Array;\n            case \"i64\":\n                return BigInt64Array;\n            case \"f32\":\n                return Float32Array;\n            case \"f64\":\n                return Float64Array;\n            default:\n                throw new Error(\"Invalid memory type \" + memType + \" in getMemoryType()\");\n        }\n    }\n\n    // Accessing aligned memory is faster because we can just treat the whole\n    // memory object as the relevant typed array (Like Uint32Array)\n    // This is not as thorough, however, because we will miss matching values\n    // that are not stored at naturally-aligned addresses\n    alignedMemory(memTypeStr) {\n        const memType = this.getMemoryType(memTypeStr);\n\n        // We return a new object each time because the WebAssembly.Memory object\n        // will detach if it is resized\n        return new memType(this.memory.buffer);\n    }\n\n    // When we need to access unaligned memory addresses, we treat memory as a\n    // Uint8Array so that we can read at any \"real\" address\n    unalignedMemory() {\n        return new Uint8Array(this.memory.buffer);\n    }\n\n    getMemorySize() {\n        return this.unalignedMemory().length;\n    }\n\n    search(memType, searchValue, lowerBound, upperBound) {\n        const result = {};\n\n        let realLowerBound = parseInt(lowerBound);\n        let realUpperBound = parseInt(upperBound);\n\n        if (realLowerBound < 0) {\n            realLowerBound = 0;\n        }\n\n        const memSize = this.getMemorySize();\n\n        if (realUpperBound >= memSize) {\n            realUpperBound = memSize - 1;\n        }\n\n        let realParam;\n\n        switch (memType) {\n            case \"ascii\":\n                realParam = new Uint8Array(searchValue.length);\n\n                for (let i = 0; i < searchValue.length; i++) {\n                    realParam[i] = searchValue.charCodeAt(i);\n                }\n\n                break;\n            case \"utf-8\":\n                const tempBuf = new Uint16Array(searchValue.length);\n\n                for (let i = 0; i < searchValue.length; i++) {\n                    realParam[i] = searchValue.charCodeAt(i);\n                }\n\n                realParam = new Uint8Array(tempBuf.buffer);\n\n                break;\n            case \"bytes\":\n                if (Array.isArray(searchValue)) {\n                    realParam = new Uint8Array(searchValue);\n                } else {\n                    const split1 = [...searchValue.trim().matchAll(/\\\\x[0-9a-f]{2}(?![0-9a-z])/gi)];\n                    const split2 = searchValue.trim().split(/\\\\x/);\n\n                    if ((split1.length != (split2.length - 1)) || split1.length == 0) {\n                        // Something is wrong in the byte sequence\n                        console.error(\"Wrong byte sequence format\");\n                        return;\n                    }\n\n                    split2.shift();\n\n                    realParam = new Uint8Array(split2.length);\n                    for (let i = 0; i < searchValue.length; i++) {\n                        realParam[i] = parseInt(split2[i], 16);\n                    }\n                }\n\n                break;\n        }\n\n        const searchResults = this.bytesSequence(realParam);\n\n        result.results = {};\n\n        for (let i = 0; i < searchResults.length; i++) {\n            const hitAddr = searchResults[i];\n            result.results[hitAddr] = searchValue;\n            wyff.logger.info(`${toHex(hitAddr)}: ${searchValue}`);\n        }\n\n        result.count = searchResults.length;\n\n        return result;\n    }\n\n    bytesSequence(bytesSeq) {\n        wyff.logger.debug(\"bytesSequence: entering bytes sequence search with parameter \" + bytesSeq);\n\n        if (bytesSeq.length < 1) {\n            wyff.logger.error(\"Minimum length must be at least 1!\");\n            return [];\n        } else if (bytesSeq.length < 4) {\n            wyff.logger.debug(\"Sequence length is small: \" + bytesSeq.length + \". This will probably return a lot of results!\");\n        }\n\n        const results = [];\n        const memory = this.alignedMemory(\"i8\");\n        let match = 0;\n\n        for (let i = 0; i < memory.length; i++) {\n            const thisByte = memory[i];\n\n            if (thisByte == bytesSeq[match]) {\n                match++;\n                continue;\n            }\n            \n            if (match == bytesSeq.length) {\n                results.push(i - bytesSeq.length);\n                match = 0;\n                wyff.logger.debug(\"bytesSequence: sequence found: \" + bytesSeq);\n            } else {\n                match = 0;\n            }\n        }\n\n        wyff.logger.debug(\"bytesSequence: exiting bytes sequence search\");\n        return results;\n    }\n\n    readBytes(address, size = 16, intSize = 8, transformer = { asAscii: false, unsigned: true }) {\n        const bytes = [];\n        let buffer;\n        if (intSize === 8) {\n            if (transformer.unsigned) {\n                buffer = new Uint8Array(this.memory.buffer);\n            } else {\n                buffer = new Int8Array(this.memory.buffer);\n            }\n        } else if (intSize === 32) {\n            if (transformer.unsigned) {\n                buffer = new Uint32Array(this.memory.buffer);\n            } else {\n                buffer = new Int32Array(this.memory.buffer);\n            }\n        }\n        for (let i = 0; i < size; i++) {\n            bytes.push(buffer[address + i]);\n        }\n    \n        if (transformer.asAscii) {\n            return bytes.map(byte => String.fromCharCode(byte)).join('');\n        }\n    \n        return bytes;\n    }\n    \n}","export function base64ToArrayBuffer(base64) {\n    var binaryString = atob(base64);\n    var bytes = new Uint8Array(binaryString.length);\n    for (var i = 0; i < binaryString.length; i++) {\n        bytes[i] = binaryString.charCodeAt(i);\n    }\n    return bytes.buffer;\n}","export default function toHex(i) {\n\treturn '0x' + parseInt(i).toString(16).padStart(8, '0');\n};","function _now() {\n    return new Date().toISOString().replace(\"T\", \" \").replace(\"Z\", \"\");\n}\n\nconst prefixStyle = [\n    \"font-size: 1.6em\",\n    \"font-weight: bold\",\n    \"text-transform: uppercase\",\n].join(\";\");\n\nexport default class Log {\n    constructor(infoWriter, debugWriter, errorWriter) {\n        this.infoWriter = infoWriter || console.log;\n        this.debugWriter = debugWriter || console.debug;\n        this.errorWriter = errorWriter || console.error;\n    }\n\n    info(...args) {\n        this.infoWriter(`%c[WYFF]%c [${_now()}] INFO\\t%s`, prefixStyle, \"\", ...args);\n    }\n\n    debug(...args) {\n        this.debugWriter(`%c[WYFF]%c [${_now()}] DEBUG\\t%s`, prefixStyle, \"\", ...args);\n    }\n\n    error(...args) {\n        this.errorWriter(`%c[WYFF]%c [${_now()}] ERROR\\t%s`, prefixStyle, \"\", ...args);\n    }\n}\n","/**\n * Simple object check.\n * @param item\n * @returns {boolean}\n */\nexport function isObject(item) {\n    return (item && typeof item === 'object' && !Array.isArray(item));\n}\n\n/**\n * Deep merge two objects.\n * @param target\n * @param ...sources\n */\nexport function mergeDeep(target, ...sources) {\n    if (!sources.length) return target;\n    const source = sources.shift();\n\n    if (isObject(target) && isObject(source)) {\n        for (const key in source) {\n            if (isObject(source[key])) {\n                if (!target[key]) Object.assign(target, { [key]: {} });\n                mergeDeep(target[key], source[key]);\n            } else {\n                Object.assign(target, { [key]: source[key] });\n            }\n        }\n    }\n\n    return mergeDeep(target, ...sources);\n}","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import Log from \"../utils/log.js\";\nimport RemoveDebuggerProtection from \"./hooks/remove-debugger-protection.js\";\nimport HookWasmTriggers from \"./hooks/wasm-triggers.js\";\nimport EncryptionInstrument from \"./instrumenter/instruments/encryption.js\";\nimport DecryptionInstrument from \"./instrumenter/instruments/decryption.js\";\nimport BinaryInstrumenter from \"./instrumenter/index.js\";\nimport { MemoryWrapper } from \"./memory/index.js\";\nimport HookEmval from \"./instrumenter/instruments/hook-emval.js\";\n// import setCanvasStyles from \"./hooks/set-canvas-styles.js\";\nimport WebsocketHooks from \"./hooks/websocket.js\";\nimport EmscriptenHooks from \"./hooks/emscripten.js\";\nimport MemoryInstrument from \"./instrumenter/instruments/memory.js\";\n// import ResourceFilesInstrument from \"./instrumenter/instruments/resource-files.js\";\n\nclass Wyff {\n    constructor() {\n        this.logger = new Log();\n        this.binaryInstrumenter = new BinaryInstrumenter();\n        this.removeDebuggerProtection = new RemoveDebuggerProtection();\n        this.hookWasmTriggers = new HookWasmTriggers();\n        this.websocketHooks = new WebsocketHooks();\n        this.emscriptenHooks = new EmscriptenHooks();\n\n        this.decryptionXorKeyMemoryAddress = null;\n        this.decryptionXorKey = null;\n        this.encryptionXorKeyMemoryAddress = null;\n        this.encryptionXorKey = null;\n    }\n\n    init() {\n        wyff.logger.info(`initializing wyff`);\n\n        // remove debugger protection\n        this.removeDebuggerProtection.do();\n        // register our binary instruments\n        this._registerInstruments();\n        // hook websockets \n        this.websocketHooks.init();\n        // hook wasm triggers\n        this.hookWasmTriggers.do((...args) => {\n            // call hooks when the wasm module is initiating\n            this._onWasmInitiating();\n            // run our binary instrumenters!\n            return this.binaryInstrumenter.run(...args);\n        });\n    }\n\n    sendFakeMessage(bytes) {\n        const ws = this.websocketHooks.getActiveWebsocket();\n        const event = new MessageEvent('message', {\n            data: new Uint8Array(bytes),\n            origin: ws.url.trimEnd('/'),\n        });\n        ws.onmessage(event);\n    }\n\n    _onWasmInitiating() {\n        // when wasm is initiating, it is guaranteed that emscripten functions have been \n        // defined. so now we can hook them.\n\n        // also register a post-run hook\n        window.addOnPostRun(() => {\n            this._onWasmPostRun();\n        });\n        this.emscriptenHooks.init();\n        // setCanvasStyles();\n    }\n\n    _onWasmPostRun() {\n        wyff.logger.info(`wasm post run`);\n        // pull the xor keys\n        this.memoryWrapper = new MemoryWrapper(wasmMemory);\n\n        if (this.decryptionXorKeyMemoryAddress) {\n            this.decryptionXorKey = this.memoryWrapper.readBytes(this.decryptionXorKeyMemoryAddress, 32);\n            wyff.logger.info(`decryption xor key: ${this.decryptionXorKey.join(\"\\t\")}`);\n        }\n\n        if (this.encryptionXorKeyMemoryAddress) {\n            this.encryptionXorKey = this.memoryWrapper.readBytes(this.encryptionXorKeyMemoryAddress, 32);\n            wyff.logger.info(`encryption xor key: ${this.encryptionXorKey.join(\"\\t\")}`);\n        }\n\n    }\n\n    _registerInstruments() {\n        this.binaryInstrumenter.add(\"memory\", new MemoryInstrument);\n        this.binaryInstrumenter.add(\"encryption\", new EncryptionInstrument);\n        this.binaryInstrumenter.add(\"decryption\", new DecryptionInstrument);\n        // this.binaryInstrumenter.add(\"resource_files\", new ResourceFilesInstrument);\n        this.binaryInstrumenter.add(\"hook\", new HookEmval);\n    }\n}\n\nwindow.wyff = new Wyff();\nwindow.wyff.init();\n"],"names":[],"sourceRoot":""}